평면
  평면은 무한히 늘릴 수 있는 1차원 도형인 직선과 비슷하게 무한히 늘릴 수 있는 완전히 평평한 2차원 곡면
  게임에서 평면은 주로 지면이나 벽을 추상화해서 표현하는 요도로 쓰이지만 다른 용도로도 쓰임
  평면표현방식은 다양하지만 프로그래머가 선호하는 방식은 다음과 같음
  <img src="/01_plane.jpg">
  P는 평면위에 있는 임의의 점, n^은 평면의 법선, d의 절댓값은 평면과 원점의 최소거리
  이렇게 표현하는 방식이 널리 쓰이는 이유는 임의의 삼각형이 있을 때 즉시 삼각형을 포함하는 평면의 방정식을 만들어낼 수 있기 때문
  또한 n^과 d를 계산하고나면 이 방정식을 통해 임의의 점 P가 평면에 속하는지 알 수 있음
  <img src="/02_triangle_ABC.jpg">
  두르기 순서가 시계방향인 삼각형이 속한 평면의 방정식을 만들려면 먼저 두 벡터의 외적하고 정규화를 통해 삼각형의 법선 n^을 계산해야함
  외적의 결과는 두르기 순서에 따라 달라지므로 유의 n^을 구한 뒤에 d를 구하려면 평면에 속하는 임의의 점이 필요한데 삼각형을 이루는 점 A,B,C를 이용
  세 점과 n^의 내적을 구할 수 있으며 스칼라 투영이므로 정규화 하지않은 P와 n^의 내적의 결과는 d의 값과 같음
  n^과 d를 구하고 나면 다음과 같은 Plane구조체에 저장할 수 있음
struct Plane
  Vector3 normal
  float d
end

반직선(ray)과 선분 
  반직선 : 임의의 점에서 시작해 한 방향으로 무한히 늘어나는 선. 일반적으로 게임에서 반직선을 표현할 때는 매개변수함수를 사용
  <img src="/03_ray_parameter.jpg">
  R0는 평면상의 시작점, v->는 반직선이 뻗어나가는 방향, t는 매개변수로 0이거나 0보다 커야함
    t가 0이면 이 매개변수함수의 수행결과는 항상 시작점인 R0임
  선분과 반직선은 비슷하지만 시작점과 끝점을 모두 지닌다는 차이가 있음, 선분 역시 매개변수함수를 사용해서 표현이 가능하나 끝점이 있어야하므로 t가 최댓값이 있어야함
  레이캐스트(raycast) : 반직선을 무한히 늘려서 반직선과 하나 이상의 오브젝트가 교차하는지 확인하는 방법
  하지만 대개 게임세계의 크기는 제한적이므로 반직선보다 더 제한적인 선분을 사용하는 쪽이 타당하긴 함. 하지만 용어가 레이캐스트로 굳어버림
  레이캐스트는 3D게임 곳곳에서 볼 수 있음. 
    예시)총알같은 경우 속도가 매우 빠르므로 레이캐스트를 적용해도 됨
    아군인지 적군인지에 따라 빨간색이나 녹색으로 바뀌는 조준선 구현
    프래넬 회절을 사용해서 적이 시야에 들어왔는지 확인할 때
    마우스로 클릭한 3D 세계의 오브젝트를 확인할 때
  레이캐스트는 선분을 사용하므로 최소한 레이캐스트의 시작점과 끝점을 나타낼 두 개의 파라미터가 필요
struct RayCast
  Vector3 startPoint
  Vector3 endPoint
end 

  startPoint와 endPoint를 선분의 매개변수형태로 변환하는 방법은 간단. R0는 startPoint와 같고 v->는 endPoint-startPoint.
  이런식으로 변환하고 나면 t는 레이캐스트의 범위에 따라 0~1까지의 값을 지님
  
충돌체(collider, collision geometry, collision hull, collision mesh 등...)
  3D게임의 인간형 캐릭터는 대개 15000개 이상의 폴리곤으로 이루어져있어 두 캐릭터의 충돌을 확인할 때 모든 폴리곤을 대상으로 일일히 확인하는 방법은 굉장히 비효율적
  이런 이유로 대부분 게임은 구체나 상자형태로 간략하게 표현한 충돌체를 사용
  충돌체는 화면에 표시하지 않고 충돌을 효율적으로 확인하는 용도로만 사용, 오브젝트에 여러단계의 충돌체를 적용한 게임도 많음
  예시) 구체형태로 오브젝트의 충돌가능성을 따져본 후 충돌 가능성이 있다면 좀 더 복잡한 충돌체를 사용하여 실제 충돌을 계산
  
경계구체
  가장 간단한 현태의 충돌체, 2D게임에서는 구체가 아닌 원을 사용. 구의 중앙을 나타내는 벡터와 구의 반지름을 나타내는 스칼라값 두 개의 변수로 정의 가능
class BoundingSphere 
  Vector3 center
  float radius
end
  
  경계와 오브젝트의 크기가 일치하지 않을 경우 두 게임 오브젝트가 겹치지 않았는데도 충돌로 판정하는 긍정오류(false positive)가 발생함
  쉽게, 즉시 충돌을 확인할 수 있으므로 일차적인 충돌확인용으로 괜찮음
축 정렬 경계 상자(AABB, Axis-Aligned Bounding Box)
  모든 모서리가 x축 또는 y축과 평행한 직사각형, 3D에서는 모든 면이 좌표축 평면중 하나와 평행한 사각기둥.
  2D에서든 3D에서든 AABB는 최소 점과 최대 점, 두 점으로 표현할 수 있음. 2D에서 최소 점은 직사각형의 왼쪽아래, 최대 점은 오른쪽위
class AABB2D 
  Vector2 min
  Vector2 max
end 
  AABB의 모든 면은 좌표축과 평행한 상태를 유지해야하므로 오브젝트가 회전하면 AABB의 크기가 바뀔 수 있다. 
  하지만 3D게임에서 인간형 캐릭터는 보통 위쪽을 향하는 축만을 기준으로 회전하므로 이런 경우 AABB의 크기를 바꿀 필요가 없음
  AABB의 충돌확인은 구체의 충돌확인보다 크게 복잡하지도 않음. 이러한 이유로 AABB는 인간형 캐릭터의 기본적인 충돌체로 많이 쓰임
방향성이 있는 경계상자(OOB, Orientied Bounding Box)
  OBB는 AABB와 비슷하지만 평행에 관한 제약이 없다
  정확성이 높은만큼 충돌계산방법이 AABB보다 훨씬 복잡함
  게임에서는 여덟개의 버텍스, 혹은 여섯개의 평면 등 다양한 방식으로 표현할 수 있음
캡슐
  위아래에 두 개의 반원을 붙인 AABB
  3D세계에서는 위아래에 두 개의 반구를 붙인 원통(cylinder)
  인간형 캐릭터에 조금 더 잘 들어맞으므로 충돌체로 많이 쓰임
  또한 캡슐은 반경을 지니는 두꺼운 선분으로 생각할 수 있음, 이럴 경우 게임엔진에서는 다음 코드로 표현함
struct Capsule2D
  Vector2 startPoint
  Vector2 endPoint
  float radius
end

볼록 다각형
  그 밖에 충돌체로 임의의 볼록 다각형을 사용할 수도 있고, 3D에서는 볼록 선체(convex hull)을 사용
  볼록 다각형을 사용하면 다른 형태의 충돌체보다 효율성은 떨어지나 정확성은 높일 수 있음
  여전히 긍정오류가 발생하긴 하나 다른 형태의 충돌체보다는 적음
충돌체 목록 
  충돌 확인의 정확성을 높일 수 있는 마지막 방법은 실제로 충돌을 확인할 여러 충돌체를 묶어서 충돌체 목록을 만드는 것
  인간형 캐릭터라면 머리에는 구체, 몸통에는 AABB, 팔다리에는 볼록 다각형을, 부분마다 다른 형태의 충돌체를 사용하면 긍정 오류를 거의 완벽하게 없앨 수 있음
  충돌체 목록의 충돌을 확인하는 속도는 모델을 구성하는 모든 삼각형의 충돌을 확인하는 속도보다는 빠르겠지만, 기본적인 충돌체를 사용할 때에 비하면 느릴 수밖에 없음
  예시)인간형 모델이라면 AABB나 캡슐로 일차적인 충돌을 확인하고 충돌이란 판정이 나왔을 때, 충돌체 목록으로 충돌을 확인. 충돌에 따라 적용할 정확도를 나눌 필요가 있음

충돌확인 알고리즘
  구체와 구체의 교차
    두 구체의 중심사이 거리가 두 구체의 반지름을 합한 길이보다 짧으면 교차했다는 의미, 부담되는 연산인 제곱근을 쓰지않고 제곱된 값을 비교하는 방법을 많이 씀
function SphereIntersection(BoundingSphere a, BoundingSphere b)
  //두 구체의 중심을 잇는 벡터를 만들고 길이의 제곱을 구함
  Vector3 centerVector = b.center - a.center
  //벡터 v의 길이의 제곱은 v와 v의 내적과 같음
  float distSquared = DotProduct( centerVector, centerVector)
  
  //distSquared가 두 구체의 반지름을 합한 값의 제곱보다 작은지 확인
  if distSquared < ((a.radius + b.radius) * (a.radius + b.radius))
    return true
  else
    return false
  end
end

  AABB와 AABB의 교차
    2D든 3D든 AABB의 교차확인은 복잡하지 않음. 2D를 기준으로 설명
    분리 축 이론이라는 알고리즘을 매우 독특하게 응용한 알고리즘임, 이는 모든 볼록다각형에 적용할 수 있으나 자세히 설명하진 않음
    2D에서 AABB사이의 교차를 확인할 때는 두 AABB가 교차하는지 확인하는 것보다 절대로 교차할 수 없는 네 가지 조건을 확인하는 쪽이 쉬움
    네 가지 조건 중 하나라도 참이면 두 AABB가 교차하지 않는다는 뜻이므로 교차를 확인하는 함수는 거짓을 리턴해야함
function AABBIntersection(AABB2D a, AABB2D b)
  bool test = (a.max.x < b.min.x) || (b.max.x < a.min.x) || (a.max.y < b.min.y) || (b.max.y < a.min.y)
  return !test
end

  선분과 평면의 교차
    선분과 평면의 충돌확인은 게임에서 비교적 흔한 충돌확인임
    선형대수학을 사용해 공식을 유도하면 선분과 평면의 충돌확인 알고리즘의 작용 방식을 쉽게 이해할 수 있음. 일단 선분과 평면의 방정식은 다음과 같음
    <img src="/04_line_plane_equation.jpg">
    R(t)를 평면상의 점으로 만드는 t가 있는지 즉, R(t)가 평면 방정식의 P를 만족할 수 있는 t값이 있는지 확인하려 함
    P를 R(t)로 치환한다면 확인할 수 있음
    <img src="/05_line_plane_equation2.jpg">
    선분에서 t=0이면 시작점, t=1이면 끝점이라는 사실이 있음, 이 범위를 벗어나는 값이 나오면 무시해야함. t가 음수면 선분이 평면에서 벗어나 있다는 의미
    <img src="/06_line_plane_intersection.jpg">
    v->와 n^의 내적이 0이라면 제수가 0이 되어 나눗셈을 할 수 없는데, 이는 두 벡터가 수직임을 의미하고 v->와 평면이 평행하다는 의미
    선분과 평면이 교차하면 t 값을 통해 실제 교차가 일어나는 점의 위치를 쉽게 얻을 수 있음
선분과 평면의 교차를 확인하는 함수
//리턴 값으로 사용할 구조체
struct LSPlaneReturn
  bool intersects
  Vector3 point
end

//레이캐스트는 사실 선분을 사용
function LSPlaneIntersection(RayCast r, Plane p)
  LSPlaneReturn retVal
  retVal.intersects = false
  
  //매개변수 선분 방적식으로 v를 계산
  Vector3 v = r.endPoint - r.startPoint
  
  //선분과 평면이 평행한지 확인
  float vDotn = DotProduct(v, p.normal)
  if vDotn is not approximately 0
    t = -1 * (DotProduct(r.startPointm p.normal) + p.d)
    t /= vDotn
    
    //t는 startPoint와 endPoint사이의 값, 즉 0~1 사이어야 함
    if t >= 0 && t <= 1
      retVal.intersects = true
      
      //교차한 지점을 계산
      retval.point = r.startPoint + v * t
    end
  else
    //r.startPoint가 평면상에 위치하는지 확인
    ...
  end
  
  return retVal
end

  선분과 삼각형의 교차
    예시) 총알의 충돌체를 나타내는 선분과 삼각형의 충돌을 확인하고 싶을 때, 먼저 삼각형이 놓여있는 평면을 구해야함
    평면을 구하고나면 선분과 평면의 교차를 확인할 수 있다. 선분과 평면이 교차한다면 선분과 삼각형이 높인 평면이 교차하는 점의 위치도 구할 수 있다
    하지만 평면은 무한히 늘어나므로 교차하는 점이 삼각형의 안에 있는지 바깥쪽에 있는지 확인할 필요가 있음
    <img src="/07_triangle_intersection.jpg">
    삼각형 ABC의 두르기 순서가 시계방향이라면 A에서 B로 향하는 벡터를 만들고 A에서 확인할 점 P로 향하는 벡터를 만든다
    AB->에서 AP->로 회전하는 방향이 시계방향이라면 P는 삼각형의 변 AB->안쪽에 있다는 뜻
    이러한 과정을 BC->, CA->에도 똑같이 반복하고 모든 변의 시계방향에 있다면 P가 삼각형의 안쪽에 있다는 의미이다
    
    하지만 먼저 회전 방향이 시계 방향인지 반시계 방향인지 알아낼 방법이 필요
      오른손 좌표계에서 AB->XAP->를 계산한 결과로 나오는 벡터는 안쪽으로 들어가는 방향을 가리킴
      이는 외적의 결과로 만들어진 벡터의 방향이 삼각형의 법선인 벡터의 방향과 같다는 의미
      정규화한 두 벡터의 내적 값이 양수면 두 벡터가 얼추 같은 방향을 향하고 있다는 뜻이므로 
      AB->XAP->의 결과를 정규화 한 뒤에 삼각형의 법선과 내적한 결과가 양수라면 점 P는 AB->의 안쪽에 있다는 의미
    이 알고리즘은 삼각형뿐 아니라 하나의 평면에 놓인 모든 볼록 다각형에 적용할 수 있음
임의의 점이 볼록다각형의 안쪽에 있는지 확인하는 함수
//이 함수는 다각형을 이루는 버텍스의 두르기 순서가 시계방향일 때, 그리고 모든 버텍스가 한 평면에 속할 때만 제대로 동작
funtion PointInPolygon(Vector3 [] verts, int numSides, Vector3 point)
  //다각형의 법선을 구함
  Vector3 normal = CrossProduct(Vector3(verts[1]-verts[0]), Vector3(verts[2]-verts[1]))
  normal.Normalize()
  
  //임시로 사용할 변수
  Vector3 side, to, cross
  
  for int i = 1, i < numSides, i++
    //이전 버텍스에서 현재 버텍스로 향하는 벡터를 만듬
    side = verts[i] - verts[i-1]
    //이전 버텍스에서 점으로 향하는 벡터를 만듬
    to = poimt -verts[i-1]
    
    cross = CrossProduct(side, to)
    cross.Normalize()
    
    //이 조건이 참이면 도형의 밖에있다는 뜻
    if DotProduct(cross, normal) < 0
      return false
    end
  loop
  
  // 마지막 버텍스에서 처음 버텍스로 이어지는 마지막 변을 확인
  side = verts[0] - verts[numSides - 1]
  to = point - verts[numsides - 1]
  cross = CrossProduct(side, to)
  cross.Normalize()
  
  if DotProduct(cross, normal) < 0
    return false
  end
  
  //여기까지 왔다면 모든 변의 안쪽에 있다는 뜻
  return true
end

  구체와 평면의 교차
    예시) 날아가던 공이 벽에 부딪힐 수 있는 게임
    평면과 구체의 충돌을 가장 쉽게 확인하는 방법은 법선이 n^이고 구체의 중심을 포함하는 가상의 평면을 만든 뒤, 이 평면의 d를 구하는 것
    새로운 평면의 d에서 실제 평면의 d를 뺀 차이의 절댓값이 구의 반지름보다 작으면 구체와 평면이 교차한다는 뜻
구체와 평면의 교차를 확인하는 함수
function SpherePlaneIntersection(BoundingSphere s, Plane p)
  //법선이 p.normal이고 점 s.center를 포함하는 평면의 d를 계산
  float dSphere = -DotProduct(p.normal, s.center)
  
  //계산할 값이 원하는 범위에 속하는지 확인
  return (abs(p.d -  dSphere) < s.radius)
end

  구체 궤적 교차(swept sphere intersection)
    종이를 총알을 발사했을 때, 총알의 속도가 매우 빠르고 종이는 매우 얇아 종이와 총알이 정확하게 만나는 프레임이 존재하지 않으면
    총알이 종이를 건너뛰는 문제(bullet-through-paper problem)이 발생. 이 문제를 해결하려면 연속충돌확인(CCD, continuos collision detection)이 필요
    구체궤적교차는 움직이는 구체 두개를 사용하는 알고리즘. 입력값은 이전 프레임에서 두 구체의 위치, 현재 프레임에서 두 구채의 위치
    이때 이전 프레임은 t=0, 현재 프레임은 t=1에 해당. 이런 값을 바탕으로 프레임이 바뀌는 동안 두 구체가 충돌했는지 확인할 수 있음
    구체 궤적교차를 사용하면 순간적으로 구체와 구체의 교차를 확인할 때와 다르게 프레임 중간에 일어난 충돌도 놓치지 않음
    구체의 궤적은 캡슐과 상당히 비슷함. 시작점과 끝점, 그리고 반경을 지님(즉 이는 캡슐과 캡슐의 교차에서도 사용할 수 있다는 의미)
    선분과 평면의 교차와 마찬가지로 먼저 방정식을 풀면 이해하기 쉽다. 두 구체의 이전 프레임과 현재프레임에서의 위치를 알면 구체의 위치변화를 매개변수함수로 변환 가능
    예시) 구체P와 Q가 있을 때 두 구체의 위치를 매개변수함수로 표현
    <img src="/08_swept_sphere_intersection_1.jpg">
    두 구체 사이의 거리가 두 구체의 반지름을 합한 값이 같아지는 지점의 t값을 구하려 한다. 바로 그 지점이 교차가 일어나는 지점이기 때문인데 식으로 표현하면
    <img src="/09_swept_sphere_intersection_2.jpg">
    이 식의 문제점은 길이를 구하는 연산을 제거할 방법이 필요하다는 것
    이렇게 하려면 벡터 v->의 길이를 제곱한 값이 벡터 v->를 자기 자신과 내적한 결과와 같다는 점을 활용
    <img src="/10_swept_sphere_intersection_3.jpg">
    따라서 구체를 비교하는 식의 양변을 제곱하면 다음과 같은 식을 얻을 수 있음
    <img src="/11_swept_sphere_intersection_4.jpg">
    이제 이 식을 t에 관해 정리. 정리과정은 조금 복잡함. 먼저 P(t)와 Q(t)를 원래 식으로 치환
    <img src="/12_swept_sphere_intersection_5.jpg">
    그 다음 인수분해와 약간의 재구성을 거쳐 조금 더 정리, 수식 일부를 치환하면 더 간단하게 표현할 수 있음
    <img src="/13_swept_sphere_intersection_6.jpg">
    <img src="/14_swept_sphere_intersection_7.jpg">
    내적은 덧셈의 분배법칙이 성립하므로 두 (A+Bt)항은 FOIL을 적용해 전개할 수 있음
      FOIL : (a+b)(c+d)를 전개할 때 Fisrt(ac), Outer(ad), Inner(bc), Last(bd)로 나누는 것. 영미권 수학에서 명사,동사로 자유롭게 쓰이는 관용적표현
    <img src="/15_swept_sphere_intersection_8.jpg">
    오른쪽 항을 왼쪽으로 넘긴 뒤에 다음과 같이 치환하면 t에 관한 식이 나옴
    <img src="/16_swept_sphere_intersection_9.jpg">
    이 이차방정식을 통해 근의 공식을 이용하여 t의 값을 구할 수 있다
    <img src="/17_quadratic_fomula.jpg">
    제곱근 안에 있는 b^2 - 4ac를 판별식이라고 함
      판별식이 음수 : t는 실수 범위의 해를 지닐 수 없음
      판별식이 0 : 방정식의 유일한 해인 t에서 두 구체가 접함
      판별식이 양수 : 두 구체는 완전히 교차하며 두 해 중 작은 해, 즉 +-중에 -에 해당하는 해인 t에서 첫번째 교차가 일어남
    <img src="/18_swept_sphere_intersection_pic.jpg">
    t를 구하고 나면 ㅅ의 값이 0~1 범위에 속하는지 확인할 수 있음. t가 1보다 크다면 현재 프레임의 이후 상황에 해당하고 0보다 작으면 이전 상황에 해당.
    따라서 0~1 범위밖의 값은 신경쓸 필요 없음
구차 궤적 교차를 확인하는 함수
//p0, q0는 전 프레임에서 두 구체의 위치, p1, q1은 현재 프레임에서 두 구체의 위치
function SweptSphere(BoundingSphere p0, BoundingSphere q0, BoudingSphere p1, BoundingSphere q1)
  //먼저 매개변수 식을 사용해서 벡터 v를 계산
  Vector3 vp = p1.center - p0.center
  Vector3 vq = q1.center - q0.center
  
  //A와 B를 계산, A = P0-Q0 ,B = vp - vq
  Vector3 A = p0.center - q0.center
  Vector3 B = vp - vq
  
  //a,b,c를 계산. a는 B와 B의 내적, b는 A와 B의 내적에 2를 곱한 값, c = (A와 A의 내적) - (rp + rq) * (rp + rq)
  float a = DotProduct(B, B)
  float b = 2 * (DotProduct(A, B))
  float c = DotProduct(A, A) - ((q0.radius + p0.radius) * (q0.radius + p0.radius))
  
  //이제 판별식 (b^2 - 4ac)를 계산
  float disc = b * b - 4 * a * c
  if disc >= 0
    //t의 값이 필요하면 t = (-b-sqrt(disc)) / (2a) 를 계산. 이 함수는 단순히 교차의 발생을 나타내는 true만 리턴
    return true
  else
    //실수인 해가 없으므로 교차가 일어나지 않음
    return false
  end
end

충돌반응
  앞서 소개한 다양한 알고리즘을 사용하면 두 오브젝트의 충돌 여부를 확인할 수 있음
  하지만 게임이라면 충돌을 확인한 뒤에 충돌에 반응하는 것이 필요함
  충돌한 두 오브젝트가 서로 튕겨나가야한다고 가정. 단순히 충돌한 오브젝트의 속도를 반대로 바꿔버리는 생각을 할 수있지만 그렇게 하면 심각한 문제가 몇가지 발생
  운석이 서로 충돌한다고 생각할때, 두 운석이 한 프레임에서 교차해 속도가 반대로 바뀐다. 하지만 두 운석의 속도가 느려서 다음 프레임에서도 충돌 중이라면
  아무리 프레임이 넘어가도 계속 속도의 방향만 반대로 바뀌며 결국 한 자리에 끼어있는 상태를 벗어나지 못할 것
  이 문제를 해결하려면 두 운석의 정확한 충돌 지점을 구해야함. 충돌이 프레임 사이에 일어났다 해도 상관없음.
  운석은 충돌체로 경계 구체를 사용하므로 구체 궤적 교차를 통해 정확한 교차 시각을 구할 수 있음. 교차한 시각을 구하고 나면 교차한 시각에 해당하는 위치로 두 구체를 밀어내야함
  그런 다음 단순히 반대로 바꿔주는 등 원하는 속도를 적용하면 두 구체는 한 자리에 끼지 않고 제 갈길을 갈 수 있음
  하지만 여전히 큰 문제가 남아있음. 속도를 단순히 반대로 바꾸는 것은 올바른 반응이 아님.
  단순히 속도를 반대로 바꾸지 말고 두 운석이 교차하는 점의 접평면의 법선을 기준으로 벡터의 반사 개념을 사용하여 운석의 속도벡터를 반사해야함.
  벽에 충돌했다면 교차점의 접평면을 만들기 쉽겠지만 두 구체가 정확히 한 점에서 교차하는 경우라면 교차점의 접평면을 찾아야함
  접평면을 만들려면 먼저 교차점을 알아야함. 교차점은 선형 보간을 사용하면 쉽게 알아낼 수 있는데, 두 구체가 한 점에서 접했다면 이 접점은 결국
  두 구체의 중심을 잇는 선분 사이에 존재. 그리고 선분상에서 접점의 위치는 구체의 반지름에 의해 정해짐
  Vector3 pointOfIntersection = Lerp(A.position, B.position, A.radius / (A.radius + B.radius))
  접평면의 법선은 결국 한 구체의 중심에서 다른 구체의 중심으로 향하는 정규화한 벡터라고 요약 가능
  이제 법선과 평면상의 한 점을 알고있으므로 교차점의 접평면을 만들 수 있음. 충돌 반응이 단순히 속도벡터의 반사일 뿐이라도 평면의 법선은 구해야함
  이렇게 반사된 속도를 적용하면 운석의 충돌이 한결 자연스러워지지만 충돌 전과 후의 속도가 똑같기 때문에 뭔가 이상함
  현실 세계에서는 두 물체가 충돌할 때 충돌 전후 속도의 비율을 뜻하는 반발계수(coefficient of restitution)가 작용
    반발계수 = 충돌 전의 상대 속도 / 충돌 후의 상대 속도
  반발계수가 1보다 큰 탄성 충돌이면 충돌 전보다 충돌 후의 상대속도가 더 빨라짐
  1보다 작은 비탄성충돌이면 충돌 후에 상대 속도가 느려진다.
  더 깊게 들어갈 경우 각운동 역할까지 고려해야함
충돌의 최적화 
  충돌을 확인해야할 오브젝트의 수가 많아지면 최적화 문제가 불거짐. 고지식하게 캐릭터와 각 오브젝트를 일대일로 확인할 수 있겠지만 이는 매우 비효율적인 방법임
  특히 대부분의 오브젝트가 캐릭터와 멀리 떨어져있다면 더더욱 비효율적
  그러므로 많은 오브젝트 중 일부만 충돌을 확인할 수 있게 게임 세계를 작게 쪼갤 방법이 필요. 2D게임에서 이런 식으로 게임 세계를 쪼개는 방법의 하나로 쿼드트리라는 방법이 있음
  <img src="/19_quadtree.jpg">
  각 문자는 게임세계의 오브젝트를 나타냄, 트리의 각 노드에 하나의 오브젝트만 남을 때까지 게임 세계를 재귀적으로 4등분 해나가는 방법이라 붙은 이름
  충돌을 확인해야 할 때가 오면 먼저 플레이어와 교차가 일어난 사분면을 확인하고 즉시 나머지 세 사분면의 오브젝트를 없애버리는 등의 처리를 해야함
  그런 다음 재귀 알고리즘을 사용해서 플레이어와 충돌했을 가능성이 있는 노드를 전부 찾을 때 까지 계속 확인
  그렇게 하여 몇 개의 오브젝트만 남고 나면 일반적인 충돌 확인 알고리즘을 사용해서 플레이어와 충돌했는지 확인할 수 있음
  쿼드트리말고도 이진공간분할(BSP)이나 쿼드트리의 3D 버전인 옥트리 같은 게임공간을 나누는 알고리즘도 있지만 휴리스틱을 사용해서 확인할 대상을 거르는 알고리즘도 있음

물리학을 바탕으로 한 움직임
  오브젝트가 게임 세계를 돌아다녀야 하는 게임이라면 어떤 형태로든 물리학을 사용해 움직임을 구현해야함
  대부분의 게임이 뉴턴 물리학(고전역학)을 사용하여 움직임을 구현함. 이는 빛의 속도에 가깝게 움직이지 않는 한 가장 좋은 물리모형임
  이 책에서는 회전에 관한 힘을 배제한 가장 기본적인 선운동 역학(linear mechanics)에 초점을 맞춤
선운동 역학의 개요
  선운동 역학의 기본 요소는 힘과 질량(force and mass). 힘은 크기와 방향을 지니므로 벡터로 표현, 질량은 물체가 지니는 물질의 양을 나타내는 스칼라값
  역학의 가장 기본적인 법칙은 질량이 커지면 물체를 움직이기 힘들어진다는 것
  이론상 충분한 힘을 받은 물체는 결국 가속하기 시작하는데, 뉴턴의 제2법칙인 가속도의 법칙은 이런 개념을 함축함
  F=m*a, F는 힘, m은 질량, a는 가속도. 힘은 질량과 가속도의 곱과 같으므로 힘을 질량으로 나누면 가속도를 얻을 수 있음
  게임에서는 이 공식을 정해진 힘에 관한 가속도를 구하는 용도로 사용.
  앞으로 가속도는 시간에 관한 함수 a(t)로 표현. 가속도는 속도, 위치와 관계가있음. 위치 함수 r(t)를 미분하면 속도함수 v(t)를 얻을 수 있고, 속도 함수를 미분하면 가속도 함수가 나옴
  v(t) = dr/dt, a(t) = dv/dt
  하지만 게임에서 이런 공식은 별 가치가 없음. 게임에서는 오브젝트에 힘을 적용할 수 있어야 하며 이 힘으로 인해 시간에 따른 가속도가 정해짐.
  가속도가 정해지면 시간에 따른 속도를 구해야함. 결국 이렇게 구한 속도를 통해 오브젝트의 위치를 정할 수 있음. 
  가속도, 속도, 위치 모두 현재 시간 단계에 따라 적용해야 하므로 적분이 필요함.
  게임에서는 적분기호를 사용하는 형태의 방정식이 없기때문에 사용할 적분은 적분기호를 사용하는 익숙한 형태의 적분이 아님. 
  게임에서 임의 프레임에서의 속도와 위치를 구하려면 시간 단계에 따라 가속도를 적용해야하기 때문에 지정한 시간 단계에 따라 적분의 근삿값을 구하는
  수치적분(numeric intergration)을 사용해야함. 예시)구분구적법이나 사다리꼴의 공식을 사용해서 곡선의 면적을 계산하기
가변 시간 단계의 문제점
  물리학을 바탕으로 하는 모든 움직임에서 발생하는 중요한 문제
  수치적분의 정확성은 전적으로 시간 단계의 크기에 달려 있으므로 수치 적분을 사용하는 한, 가변 시간 단계(variable time steps)는 사용할 수 없다는 점.
  시간 단계가 작아지면 근삿값의 정확성이 높아짐
  즉, 프레임마다 시간 단계가 바뀔 수 있다는 말은 프레임마다 근사치의 정확성이 달라질 수 있다는 의미. 정확성이 달라지면 동작이 눈에 띄게 달라짐
  <img src="/20_variable_time_steps.jpg">
  예시)슈퍼마리오 브라더스처럼 점프하는 게임에 가변 시간 단계를 사용했다고 가정, 캐릭터의 점프 궤적은 항상 일정해야하지만 게임 중에 갑자기 프레임 속도가 떨어지면 캐릭터가
  평소보다 더 멀리 뛰는 현상이 일어남. 이는 프레임 속도가 떨어지면 수치적분의 오차율이 높아져서 점프의 궤적이 커지기 때문.
  즉 성능이 낮은 기기에서 플레이하면 성능이 높은 기기에서 플레이할 때 보다 더 멀리 뛸 수 있다는 뜻
  이러한 이유들로 물리학을 사용해서 위치를 계산하는 모든 게임은 물리 계산에 가변 시간 단계를 쓰지 말아야함
  전체적으로 가변 시간 단계를 사용하면서 물리 계산에만 별도의 시간 단계를 사용하는 식으로 코드를 작성할 수도 있지만, 이 방법은 다소 복잡함.
  당장은 프레임제한을 사용하는 쪽이 낫다
힘 계산
  수치 적분을 통해 가속도에서 속도를, 그리고 속도에서 위치를 구할 수 있음. 하지만 가속도를 계산하려면 힘과 질량이 필요.
  고려해야할 힘의 종류는 다양함. 중력(오브젝트에 끊임없이 작용), 충격(impulse, 한 프레임에만 작용) 등...
  예시) 캐릭터가 점프를 하려면 외부에서 충격을 가해 캐릭터를 위로 띄워야함. 점프를 시작한 뒤에는 중력이 캐릭터를 땅으로 잡아당김
  이렇듯 여러 힘이 동시에 작용할 수 있으므로 게임에서는 오브젝트에 작용하는 모든 힘의 벡터를 합한 뒤에 질량으로 나눠서 현재 가속도를 구하는 방법을 가장 많이 이용
오일러 적분과 반 암시적 오일러 적분(Euler intergration and semi-implicit Euler intergration)
  오일러적분
    가장 간단한 형태의 수치적분
    먼저 이전 위치에 이전 속도와 시간 단계를 곱한 값을 더해서 새로운 위치를 계산, 그 다음 비슷하게 가속도를 사용해서 속도를 계산
오일러 적분을 사용하는 간단한 물리 오브젝트와 업데이트 함수 코드
class PhysicsObject
  //이 오브젝트에 작용하는 모든 힘 벡터의 리스트
  List forces
  Vector3 acceleration, velocity, position
  float mass
  
  function Update(float deltaTime)
    Vector3 sumOfForces = sum of forces in forces
    acceleration = sumOfForces / mass
    
    //오일러 적분
    position += velocity * deltaTime
    velocity += acceleration * deltaTime
  end
end
    오일러 적분은 매우 간단하지만 정확성이 많이 떨어짐. 가장 큰 문제는 위치를 계산할때 시간 단계 후의 새로운 속도가 아닌 이전 속도를 사용한다는 점
    결국 시간이 흐를수록 근사치가 더 크게 벗어나는 오차 전파(propagation of error)문제가 발생
  반 암시적 오일러 적분
    기본적인 오일러 적분을 수정하는 간단한 방법은 위치계산과 속도 계산의 순서를 바꾸는 것인데, 이는 이전속도가 아닌 새로운 속도를 바탕으로 위치를 업데이트 한다는 의미
    이런 방법을 반 암시적 오일러 적분이라고 하며 다른 물리엔진에 쓰일 정도로 상당히 안정적인 결과를 얻을 수 있는 적분법임
    하지만 더욱 정확한 결과를 얻으려면 좀 더 복잡한 수치 적분 방법을 살펴야함
베를레 적분(Verlet velocity integration)
  베를레 적분에서는 먼저 이전 시간 단계와 현재 시간 단계의 중간 시점에서의 속도를 계산함. 이 평균 속도를 사용해 해당 시간 단계에서의 위치를 적분
  그런 다음 힘과 질량을 바탕으로 새로운 가속도를 구하고, 시간 단계가 끝나는 시점에 새로운 가속도를 적용함
베를레 적분 코드
function Update(float deltaTime)
  Vector3 sumOfForces = sum of forces in forces
  
  //베를레 적분으로 평균 속도를 구함
  Vector3 avgVelocity = velocity + acceleration * deltaTime / 2.0f
  //평균 속도를 적분해서 위치를 구함
  position += avgVelocity * deltaTime
  // 새로운 가속도와 속도를 계산
  acceleration = sumOfForces / mass
  velocity = avgVelocity + acceleration * deltaTime / 2.0f
end
  평균속도와 평균가속도를 함께 사용해서 적분하는 베를레 적분은 기본적으로 오일러적분과 반 암시적 오일러적분보다 훨씬 정확함
  계산량이 많지만 부담스러운 수준은 아님

기타 적분 방법
  좀더 복잡하기는 해도 게임에 사용할 수 있는 다양한 적분 방법이 존재
  가장 널리 쓰이는 방법 중 하나는 4차 룽게 쿠다(Runge-Kutta)법.
    기본적으로 테일러 그사를 사용햇 ㅓ움직임을 나타내는 다양한 방정식 해의 근사해를 구하는 방법
    오일러 적분, 베를레 적분보다 더 정확하지만 계산 속도가 느리다는 단점
    레이싱 게임처럼 매우 정확한 적분이 필요한 게임이라면 몰라도 대부분의 게임에 적용하기에는 지나친 감이 있음
각운동 역학(angular mechanics)
  회전에 관한 물리학. 예시)밧줄에 묶여서 다른 오브젝트의 주위를 회전하는 오브젝트를 표현하려면 이런 물리학이 필요할 수 있음
  선운동 역학에 질량, 힘, 가속도, 속도, 위치가 있듯이 각운동 역학에는 관성모멘트, 토크, 각가속도, 각속도, 각도(각위치)가 있음
  각운동 영ㄱ학의 방정식은 선운동 역학의 방정식보다 조금 더 복잡할 뿐 많이 복잡하지는 않음
  게임에 각운동역학을 뱌ㅏㄴ영하려면 선운동 역학과 마찬가지로 수치 적분을 사용해야함. 예시)당구 게임 등

물리학 미들웨어
  물리학은 복잡하고 방대한 분야이므로 게임 개발사가 물리에 관한 기능을 직접 구현하지 않고 물리 미들웨어 패키지를 사용하는 것은 지극히 흔한일
  가장 대중적인 3D 게임용 물리 미들웨어는 하복 피직스(Havok Phusucs). 이는 유료게임엔진이지만 소규모 개발사용 버전도 있음
  그 밖에 후보 : 언리얼엔진, 유니티엔진의 기본 물리 시스템으로 채택되어 유명세를 탄 PhysX, 연 매출이 10만달러 미만인 게임개발자라면 무료로 사용 가능
  2D 게임에서 최고 인기를 누리는 솔루션은 오픈소스인 박스2D(http://box2d.org)
    핵심 라이브러리는 C++로 만들어져 있지만 C#, 자바, 파이썬 등 다양한 언어에서 사용 가능
    사실상 표준으로 자리잡은 2D 물리엔진임

연습문제
  1. 축 정렬 경계상자(AABB)와 방향성이 있는 경계 상자(OBB)의 차이점을 설명
    AABB는 모든 모서리가 좌표축과 평행한 직사각형, 3D AABB는 모든 면이 좌표 평면과 평행
    OBB는 이러한 제약이 없음
  2. 게임에서 가장 널리 쓰이는 평면의 방정식은 무엇인가? 그리고 그 방정식의 각 변수는 무엇을 나타내는가?
  3. 매개변수 방정식이란? 또 매개변수 방정식을 통해 반직선을 표현하는 방법을 설명
    임의의 매개변수에 관해 정의한 함수
  4. 두 구체의 교차를 효율적으로 확인하는 방법을 설명
    두 구체의 중심 사이의 거리가 반지름의 합보다 작으면 두 구체는 교차한 상태
  5. 2D에서 두 AABB의 교차를 확인하는 가장 좋은 방법은?
    AABB가 절대 교차할 수 없는 네 가지 조건을 확인하는 것
  6. 선분과 평면의 교차를 확인할 때 t값이 음수인 경우의 의미를 설명
    선분이 평면에서 벗어나 있다는 뜻
  7. 순간충돌확인과 연속충돌확인의 차이점을 설명
    순간충돌확인 알고리즘 : 현재 프레임에서 두 오브젝트가 충돌했는지만 확인
    연속충돌확인 알고리즘 : 프레임 사이에 벌어진 충돌도 확인 가능
  8. 구체 궤적 교차에서 판별식은 음수, 0, 양수일 수 있다. 세 경우의 의미를 설명
    음수 : 두 구체가 충돌하지 않음
    0 : 두 구체가 접하는 t 값이 있음
    양수 : 두 구체가 완전히 교차하며 두 해 중에 작은 해에서 첫 교차가 일어남
  9. 수치 적분을 할 때 가변 시간 단계를 사용하지 말아야 하는 이유를 설명
    수치적분의 정확성은 시간 단계의 크기와 직접적인 관계가 있는데, 시간단계의 크기가 일정하지 않으면 수치 적분의 결과가 불안정적으로 변함
  10. 베를레 적분의 작용 방식을 설명
    전 프레임의 가속도를 사용해 시간단계의 중간 시점에서의 속도를 계산
    그런 다음 계산한 속도를 모든 시간 단계에 적용해서 적분을 통해 위치를 계산
    그리고 현재 프레임의 가속도를 구한 뒤에 이 가속도를 적용해 시간 단계의 중간 시점에서 시간 단계가 끝나는 시점까지의 속도를 계산
