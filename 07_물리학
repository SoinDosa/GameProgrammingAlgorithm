평면
  평면은 무한히 늘릴 수 있는 1차원 도형인 직선과 비슷하게 무한히 늘릴 수 있는 완전히 평평한 2차원 곡면
  게임에서 평면은 주로 지면이나 벽을 추상화해서 표현하는 요도로 쓰이지만 다른 용도로도 쓰임
  평면표현방식은 다양하지만 프로그래머가 선호하는 방식은 다음과 같음
  <img src="/01_plane.jpg">
  P는 평면위에 있는 임의의 점, n^은 평면의 법선, d의 절댓값은 평면과 원점의 최소거리
  이렇게 표현하는 방식이 널리 쓰이는 이유는 임의의 삼각형이 있을 때 즉시 삼각형을 포함하는 평면의 방정식을 만들어낼 수 있기 때문
  또한 n^과 d를 계산하고나면 이 방정식을 통해 임의의 점 P가 평면에 속하는지 알 수 있음
  <img src="/02_triangle_ABC.jpg">
  두르기 순서가 시계방향인 삼각형이 속한 평면의 방정식을 만들려면 먼저 두 벡터의 외적하고 정규화를 통해 삼각형의 법선 n^을 계산해야함
  외적의 결과는 두르기 순서에 따라 달라지므로 유의 n^을 구한 뒤에 d를 구하려면 평면에 속하는 임의의 점이 필요한데 삼각형을 이루는 점 A,B,C를 이용
  세 점과 n^의 내적을 구할 수 있으며 스칼라 투영이므로 정규화 하지않은 P와 n^의 내적의 결과는 d의 값과 같음
  n^과 d를 구하고 나면 다음과 같은 Plane구조체에 저장할 수 있음
struct Plane
  Vector3 normal
  float d
end

반직선(ray)과 선분 
  반직선 : 임의의 점에서 시작해 한 방향으로 무한히 늘어나는 선. 일반적으로 게임에서 반직선을 표현할 때는 매개변수함수를 사용
  <img src="/03_ray_parameter.jpg">
  R0는 평면상의 시작점, v->는 반직선이 뻗어나가는 방향, t는 매개변수로 0이거나 0보다 커야함
    t가 0이면 이 매개변수함수의 수행결과는 항상 시작점인 R0임
  선분과 반직선은 비슷하지만 시작점과 끝점을 모두 지닌다는 차이가 있음, 선분 역시 매개변수함수를 사용해서 표현이 가능하나 끝점이 있어야하므로 t가 최댓값이 있어야함
  레이캐스트(raycast) : 반직선을 무한히 늘려서 반직선과 하나 이상의 오브젝트가 교차하는지 확인하는 방법
  하지만 대개 게임세계의 크기는 제한적이므로 반직선보다 더 제한적인 선분을 사용하는 쪽이 타당하긴 함. 하지만 용어가 레이캐스트로 굳어버림
  레이캐스트는 3D게임 곳곳에서 볼 수 있음. 
    예시)총알같은 경우 속도가 매우 빠르므로 레이캐스트를 적용해도 됨
    아군인지 적군인지에 따라 빨간색이나 녹색으로 바뀌는 조준선 구현
    프래넬 회절을 사용해서 적이 시야에 들어왔는지 확인할 때
    마우스로 클릭한 3D 세계의 오브젝트를 확인할 때
  레이캐스트는 선분을 사용하므로 최소한 레이캐스트의 시작점과 끝점을 나타낼 두 개의 파라미터가 필요
struct RayCast
  Vector3 startPoint
  Vector3 endPoint
end 

  startPoint와 endPoint를 선분의 매개변수형태로 변환하는 방법은 간단. R0는 startPoint와 같고 v->는 endPoint-startPoint.
  이런식으로 변환하고 나면 t는 레이캐스트의 범위에 따라 0~1까지의 값을 지님
  
충돌체(collider, collision geometry, collision hull, collision mesh 등...)
  3D게임의 인간형 캐릭터는 대개 15000개 이상의 폴리곤으로 이루어져있어 두 캐릭터의 충돌을 확인할 때 모든 폴리곤을 대상으로 일일히 확인하는 방법은 굉장히 비효율적
  이런 이유로 대부분 게임은 구체나 상자형태로 간략하게 표현한 충돌체를 사용
  충돌체는 화면에 표시하지 않고 충돌을 효율적으로 확인하는 용도로만 사용, 오브젝트에 여러단계의 충돌체를 적용한 게임도 많음
  예시) 구체형태로 오브젝트의 충돌가능성을 따져본 후 충돌 가능성이 있다면 좀 더 복잡한 충돌체를 사용하여 실제 충돌을 계산
  
경계구체
  가장 간단한 현태의 충돌체, 2D게임에서는 구체가 아닌 원을 사용. 구의 중앙을 나타내는 벡터와 구의 반지름을 나타내는 스칼라값 두 개의 변수로 정의 가능
class BoundingSphere 
  Vector3 center
  float radius
end
  
  경계와 오브젝트의 크기가 일치하지 않을 경우 두 게임 오브젝트가 겹치지 않았는데도 충돌로 판정하는 긍정오류(false positive)가 발생함
  쉽게, 즉시 충돌을 확인할 수 있으므로 일차적인 충돌확인용으로 괜찮음
축 정렬 경계 상자(AABB, Axis-Aligned Bounding Box)
  모든 모서리가 x축 또는 y축과 평행한 직사각형, 3D에서는 모든 면이 좌표축 평면중 하나와 평행한 사각기둥.
  2D에서든 3D에서든 AABB는 최소 점과 최대 점, 두 점으로 표현할 수 있음. 2D에서 최소 점은 직사각형의 왼쪽아래, 최대 점은 오른쪽위
class AABB2D 
  Vector2 min
  Vector2 max
end 
  AABB의 모든 면은 좌표축과 평행한 상태를 유지해야하므로 오브젝트가 회전하면 AABB의 크기가 바뀔 수 있다. 
  하지만 3D게임에서 인간형 캐릭터는 보통 위쪽을 향하는 축만을 기준으로 회전하므로 이런 경우 AABB의 크기를 바꿀 필요가 없음
  AABB의 충돌확인은 구체의 충돌확인보다 크게 복잡하지도 않음. 이러한 이유로 AABB는 인간형 캐릭터의 기본적인 충돌체로 많이 쓰임
방향성이 있는 경계상자(OOB, Orientied Bounding Box)
  OBB는 AABB와 비슷하지만 평행에 관한 제약이 없다
  정확성이 높은만큼 충돌계산방법이 AABB보다 훨씬 복잡함
  게임에서는 여덟개의 버텍스, 혹은 여섯개의 평면 등 다양한 방식으로 표현할 수 있음
캡슐
  위아래에 두 개의 반원을 붙인 AABB
  3D세계에서는 위아래에 두 개의 반구를 붙인 원통(cylinder)
  인간형 캐릭터에 조금 더 잘 들어맞으므로 충돌체로 많이 쓰임
  또한 캡슐은 반경을 지니는 두꺼운 선분으로 생각할 수 있음, 이럴 경우 게임엔진에서는 다음 코드로 표현함
struct Capsule2D
  Vector2 startPoint
  Vector2 endPoint
  float radius
end

볼록 다각형
  그 밖에 충돌체로 임의의 볼록 다각형을 사용할 수도 있고, 3D에서는 볼록 선체(convex hull)을 사용
  볼록 다각형을 사용하면 다른 형태의 충돌체보다 효율성은 떨어지나 정확성은 높일 수 있음
  여전히 긍정오류가 발생하긴 하나 다른 형태의 충돌체보다는 적음
충돌체 목록 
  충돌 확인의 정확성을 높일 수 있는 마지막 방법은 실제로 충돌을 확인할 여러 충돌체를 묶어서 충돌체 목록을 만드는 것
  인간형 캐릭터라면 머리에는 구체, 몸통에는 AABB, 팔다리에는 볼록 다각형을, 부분마다 다른 형태의 충돌체를 사용하면 긍정 오류를 거의 완벽하게 없앨 수 있음
  충돌체 목록의 충돌을 확인하는 속도는 모델을 구성하는 모든 삼각형의 충돌을 확인하는 속도보다는 빠르겠지만, 기본적인 충돌체를 사용할 때에 비하면 느릴 수밖에 없음
  예시)인간형 모델이라면 AABB나 캡슐로 일차적인 충돌을 확인하고 충돌이란 판정이 나왔을 때, 충돌체 목록으로 충돌을 확인. 충돌에 따라 적용할 정확도를 나눌 필요가 있음

충돌확인 알고리즘
  구체와 구체의 교차
    두 구체의 중심사이 거리가 두 구체의 반지름을 합한 길이보다 짧으면 교차했다는 의미, 부담되는 연산인 제곱근을 쓰지않고 제곱된 값을 비교하는 방법을 많이 씀
function SphereIntersection(BoundingSphere a, BoundingSphere b)
  //두 구체의 중심을 잇는 벡터를 만들고 길이의 제곱을 구함
  Vector3 centerVector = b.center - a.center
  //벡터 v의 길이의 제곱은 v와 v의 내적과 같음
  float distSquared = DotProduct( centerVector, centerVector)
  
  //distSquared가 두 구체의 반지름을 합한 값의 제곱보다 작은지 확인
  if distSquared < ((a.radius + b.radius) * (a.radius + b.radius))
    return true
  else
    return false
  end
end

  AABB와 AABB의 교차
    2D든 3D든 AABB의 교차확인은 복잡하지 않음. 2D를 기준으로 설명
    분리 축 이론이라는 알고리즘을 매우 독특하게 응용한 알고리즘임, 이는 모든 볼록다각형에 적용할 수 있으나 자세히 설명하진 않음
    2D에서 AABB사이의 교차를 확인할 때는 두 AABB가 교차하는지 확인하는 것보다 절대로 교차할 수 없는 네 가지 조건을 확인하는 쪽이 쉬움
    네 가지 조건 중 하나라도 참이면 두 AABB가 교차하지 않는다는 뜻이므로 교차를 확인하는 함수는 거짓을 리턴해야함
function AABBIntersection(AABB2D a, AABB2D b)
  bool test = (a.max.x < b.min.x) || (b.max.x < a.min.x) || (a.max.y < b.min.y) || (b.max.y < a.min.y)
  return !test
end

  선분과 평면의 교차
    선분과 평면의 충돌확인은 게임에서 비교적 흔한 충돌확인임
    선형대수학을 사용해 공식을 유도하면 선분과 평면의 충돌확인 알고리즘의 작용 방식을 쉽게 이해할 수 있음. 일단 선분과 평면의 방정식은 다음과 같음
    <img src="/04_line_plane_equation.jpg">
    R(t)를 평면상의 점으로 만드는 t가 있는지 즉, R(t)가 평면 방정식의 P를 만족할 수 있는 t값이 있는지 확인하려 함
    P를 R(t)로 치환한다면 확인할 수 있음
    <img src="/05_line_plane_equation2.jpg">
    선분에서 t=0이면 시작점, t=1이면 끝점이라는 사실이 있음, 이 범위를 벗어나는 값이 나오면 무시해야함. t가 음수면 선분이 평면에서 벗어나 있다는 의미
    <img src="/06_line_plane_intersection.jpg">
    v->와 n^의 내적이 0이라면 제수가 0이 되어 나눗셈을 할 수 없는데, 이는 두 벡터가 수직임을 의미하고 v->와 평면이 평행하다는 의미
    선분과 평면이 교차하면 t 값을 통해 실제 교차가 일어나는 점의 위치를 쉽게 얻을 수 있음
선분과 평면의 교차를 확인하는 함수
//리턴 값으로 사용할 구조체
struct LSPlaneReturn
  bool intersects
  Vector3 point
end

//레이캐스트는 사실 선분을 사용
function LSPlaneIntersection(RayCast r, Plane p)
  LSPlaneReturn retVal
  retVal.intersects = false
  
  //매개변수 선분 방적식으로 v를 계산
  Vector3 v = r.endPoint - r.startPoint
  
  //선분과 평면이 평행한지 확인
  float vDotn = DotProduct(v, p.normal)
  if vDotn is not approximately 0
    t = -1 * (DotProduct(r.startPointm p.normal) + p.d)
    t /= vDotn
    
    //t는 startPoint와 endPoint사이의 값, 즉 0~1 사이어야 함
    if t >= 0 && t <= 1
      retVal.intersects = true
      
      //교차한 지점을 계산
      retval.point = r.startPoint + v * t
    end
  else
    //r.startPoint가 평면상에 위치하는지 확인
    ...
  end
  
  return retVal
end

  선분과 삼각형의 교차
    예시) 총알의 충돌체를 나타내는 선분과 삼각형의 충돌을 확인하고 싶을 때, 먼저 삼각형이 놓여있는 평면을 구해야함
    평면을 구하고나면 선분과 평면의 교차를 확인할 수 있다. 선분과 평면이 교차한다면 선분과 삼각형이 높인 평면이 교차하는 점의 위치도 구할 수 있다
    하지만 평면은 무한히 늘어나므로 교차하는 점이 삼각형의 안에 있는지 바깥쪽에 있는지 확인할 필요가 있음
    <img src="/07_triangle_intersection.jpg">
    삼각형 ABC의 두르기 순서가 시계방향이라면 A에서 B로 향하는 벡터를 만들고 A에서 확인할 점 P로 향하는 벡터를 만든다
    AB->에서 AP->로 회전하는 방향이 시계방향이라면 P는 삼각형의 변 AB->안쪽에 있다는 뜻
    이러한 과정을 BC->, CA->에도 똑같이 반복하고 모든 변의 시계방향에 있다면 P가 삼각형의 안쪽에 있다는 의미이다
    
    하지만 먼저 회전 방향이 시계 방향인지 반시계 방향인지 알아낼 방법이 필요
      오른손 좌표계에서 AB->XAP->를 계산한 결과로 나오는 벡터는 안쪽으로 들어가는 방향을 가리킴
      이는 외적의 결과로 만들어진 벡터의 방향이 삼각형의 법선인 벡터의 방향과 같다는 의미
      정규화한 두 벡터의 내적 값이 양수면 두 벡터가 얼추 같은 방향을 향하고 있다는 뜻이므로 
      AB->XAP->의 결과를 정규화 한 뒤에 삼각형의 법선과 내적한 결과가 양수라면 점 P는 AB->의 안쪽에 있다는 의미
    이 알고리즘은 삼각형뿐 아니라 하나의 평면에 놓인 모든 볼록 다각형에 적용할 수 있음
임의의 점이 볼록다각형의 안쪽에 있는지 확인하는 함수
//이 함수는 다각형을 이루는 버텍스의 두르기 순서가 시계방향일 때, 그리고 모든 버텍스가 한 평면에 속할 때만 제대로 동작
funtion PointInPolygon(Vector3 [] verts, int numSides, Vector3 point)
  //다각형의 법선을 구함
  Vector3 normal = CrossProduct(Vector3(verts[1]-verts[0]), Vector3(verts[2]-verts[1]))
  normal.Normalize()
  
  //임시로 사용할 변수
  Vector3 side, to, cross
  
  for int i = 1, i < numSides, i++
    //이전 버텍스에서 현재 버텍스로 향하는 벡터를 만듬
    side = verts[i] - verts[i-1]
    //이전 버텍스에서 점으로 향하는 벡터를 만듬
    to = poimt -verts[i-1]
    
    cross = CrossProduct(side, to)
    cross.Normalize()
    
    //이 조건이 참이면 도형의 밖에있다는 뜻
    if DotProduct(cross, normal) < 0
      return false
    end
  loop
  
  // 마지막 버텍스에서 처음 버텍스로 이어지는 마지막 변을 확인
  side = verts[0] - verts[numSides - 1]
  to = point - verts[numsides - 1]
  cross = CrossProduct(side, to)
  cross.Normalize()
  
  if DotProduct(cross, normal) < 0
    return false
  end
  
  //여기까지 왔다면 모든 변의 안쪽에 있다는 뜻
  return true
end

  구체와 평면의 교차
    예시) 날아가던 공이 벽에 부딪힐 수 있는 게임
    평면과 구체의 충돌을 가장 쉽게 확인하는 방법은 법선이 n^이고 구체의 중심을 포함하는 가상의 평면을 만든 뒤, 이 평면의 d를 구하는 것
    새로운 평면의 d에서 실제 평면의 d를 뺀 차이의 절댓값이 구의 반지름보다 작으면 구체와 평면이 교차한다는 뜻
구체와 평면의 교차를 확인하는 함수
function SpherePlaneIntersection(BoundingSphere s, Plane p)
  //법선이 p.normal이고 점 s.center를 포함하는 평면의 d를 계산
  float dSphere = -DotProduct(p.normal, s.center)
  
  //계산할 값이 원하는 범위에 속하는지 확인
  return (abs(p.d -  dSphere) < s.radius)
end

  구체 궤적 교차(swept sphere intersection)
    종이를 총알을 발사했을 때, 총알의 속도가 매우 빠르고 종이는 매우 얇아 종이와 총알이 정확하게 만나는 프레임이 존재하지 않으면
    총알이 종이를 건너뛰는 문제(bullet-through-paper problem)이 발생. 이 문제를 해결하려면 연속충돌확인(CCD, continuos collision detection)이 필요
    구체궤적교차는 움직이는 구체 두개를 사용하는 알고리즘. 입력값은 이전 프레임에서 두 구체의 위치, 현재 프레임에서 두 구채의 위치
    이때 이전 프레임은 t=0, 현재 프레임은 t=1에 해당. 이런 값을 바탕으로 프레임이 바뀌는 동안 두 구체가 충돌했는지 확인할 수 있음
    구체 궤적교차를 사용하면 순간적으로 구체와 구체의 교차를 확인할 때와 다르게 프레임 중간에 일어난 충돌도 놓치지 않음
    구체의 궤적은 캡슐과 상당히 비슷함. 시작점과 끝점, 그리고 반경을 지님(즉 이는 캡슐과 캡슐의 교차에서도 사용할 수 있다는 의미)
    선분과 평면의 교차와 마찬가지로 먼저 방정식을 풀면 이해하기 쉽다. 두 구체의 이전 프레임과 현재프레임에서의 위치를 알면 구체의 위치변화를 매개변수함수로 변환 가능
    예시) 구체P와 Q가 있을 때 두 구체의 위치를 매개변수함수로 표현
    <img src="/08_swept_sphere_intersection_1.jpg">
    두 구체 사이의 거리가 두 구체의 반지름을 합한 값이 같아지는 지점의 t값을 구하려 한다. 바로 그 지점이 교차가 일어나는 지점이기 때문인데 식으로 표현하면
    <img src="/09_swept_sphere_intersection_2.jpg">
    이 식의 문제점은 길이를 구하는 연산을 제거할 방법이 필요하다는 것
    이렇게 하려면 벡터 v->의 길이를 제곱한 값이 벡터 v->를 자기 자신과 내적한 결과와 같다는 점을 활용
    <img src="/10_swept_sphere_intersection_3.jpg">
    따라서 구체를 비교하는 식의 양변을 제곱하면 다음과 같은 식을 얻을 수 있음
    <img src="/11_swept_sphere_intersection_4.jpg">
    이제 이 식을 t에 관해 정리. 정리과정은 조금 복잡함. 먼저 P(t)와 Q(t)를 원래 식으로 치환
    <img src="/12_swept_sphere_intersection_5.jpg">
    그 다음 인수분해와 약간의 재구성을 거쳐 조금 더 정리, 수식 일부를 치환하면 더 간단하게 표현할 수 있음
    <img src="/13_swept_sphere_intersection_6.jpg">
    <img src="/14_swept_sphere_intersection_7.jpg">
    내적은 덧셈의 분배법칙이 성립하므로 두 (A+Bt)항은 FOIL을 적용해 전개할 수 있음
      FOIL : (a+b)(c+d)를 전개할 때 Fisrt(ac), Outer(ad), Inner(bc), Last(bd)로 나누는 것. 영미권 수학에서 명사,동사로 자유롭게 쓰이는 관용적표현
    <img src="/15_swept_sphere_intersection_8.jpg">
    오른쪽 항을 왼쪽으로 넘긴 뒤에 다음과 같이 치환하면 t에 관한 식이 나옴
    <img src="/16_swept_sphere_intersection_9.jpg">
    이 이차방정식을 통해 근의 공식을 이용하여 t의 값을 구할 수 있다
    <img src="/17_quadratic_fomula.jpg">
    제곱근 안에 있는 b^2 - 4ac를 판별식이라고 함
      판별식이 음수 : t는 실수 범위의 해를 지닐 수 없음
      판별식이 0 : 방정식의 유일한 해인 t에서 두 구체가 접함
      판별식이 양수 : 두 구체는 완전히 교차하며 두 해 중 작은 해, 즉 +-중에 -에 해당하는 해인 t에서 첫번째 교차가 일어남
    <img src="/18_swept_sphere_intersection_pic.jpg">
    t를 구하고 나면 ㅅ의 값이 0~1 범위에 속하는지 확인할 수 있음. t가 1보다 크다면 현재 프레임의 이후 상황에 해당하고 0보다 작으면 이전 상황에 해당.
    따라서 0~1 범위밖의 값은 신경쓸 필요 없음
구차 궤적 교차를 확인하는 함수
//p0, q0는 전 프레임에서 두 구체의 위치, p1, q1은 현재 프레임에서 두 구체의 위치
function SweptSphere(BoundingSphere p0, BoundingSphere q0, BoudingSphere p1, BoundingSphere q1)
  //먼저 매개변수 식을 사용해서 벡터 v를 계산
  Vector3 vp = p1.center - p0.center
  Vector3 vq = q1.center - q0.center
  
  //A와 B를 계산, A = P0-Q0 ,B = vp - vq
  Vector3 A = p0.center - q0.center
  Vector3 B = vp - vq
  
  //a,b,c를 계산. a는 B와 B의 내적, b는 A와 B의 내적에 2를 곱한 값, c = (A와 A의 내적) - (rp + rq) * (rp + rq)
  float a = DotProduct(B, B)
  float b = 2 * (DotProduct(A, B))
  float c = DotProduct(A, A) - ((q0.radius + p0.radius) * (q0.radius + p0.radius))
  
  //이제 판별식 (b^2 - 4ac)를 계산
  float disc = b * b - 4 * a * c
  if disc >= 0
    //t의 값이 필요하면 t = (-b-sqrt(disc)) / (2a) 를 계산. 이 함수는 단순히 교차의 발생을 나타내는 true만 리턴
    return true
  else
    //실수인 해가 없으므로 교차가 일어나지 않음
    return false
  end
end

충돌반응
  앞서 소개한 다양한 알고리즘을 사용하면 두 오브젝트의 충돌 여부를 확인할 수 있음
  하지만 게임이라면 충돌을 확인한 뒤에 충돌에 반응하는 것이 필요함
  충돌한 두 오브젝트가 서로 튕겨나가야한다고 가정. 단순히 충돌한 오브젝트의 속도를 반대로 바꿔버리는 생각을 할 수있지만 그렇게 하면 심각한 문제가 몇가지 발생
  운석이 서로 충돌한다고 생각할때, 두 운석이 한 프레임에서 교차해 속도가 반대로 바뀐다. 하지만 두 운석의 속도가 느려서 다음 프레임에서도 충돌 중이라면
  아무리 프레임이 넘어가도 계속 속도의 방향만 반대로 바뀌며 결국 한 자리에 끼어있는 상태를 벗어나지 못할 것
  이 문제를 해결하려면 두 운석의 정확한 충돌 지점을 구해야함. 충돌이 프레임 사이에 일어났다 해도 상관없음.
  운석은 충돌체로 경계 구체를 사용하므로 구체 궤적 교차를 통해 정확한 교차 시각을 구할 수 ㅇㅆ음



