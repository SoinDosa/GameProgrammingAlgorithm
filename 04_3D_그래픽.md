## 3D의 기초
* GPU덕분에 요즘은 소프트웨어 래스터화 알고리즘을 따로 구현할 필요가 없음
  * 래스터 주사 : 점(pixel)로 이루어지는 수평 주사선을 화면의 위에서부터 아래로 내려가며 옆으로 끌듯이 한줄 씩 주사하며 화면을 형성하는 주사 방식
  * 이와 달리 펜으로 그리듯이 자유로이 주사하는 방식을 '벡터 주사'라고 함
* OpenGL과 DirectX같은 라이브러리를 사용햇 3D장면을 그리는데 필요한 데이터를 그래픽카드가 원하는 방식으로 전달하는 쪽으로 초점이 옮겨짐
* 3D게임의 경우 CG와는 다르게 60FPS정도에 맞춰서 그래픽을 그려내야하므로 CG영화와는 다르게 빛의 효과를 실사와 같은 수준으로 계산할 시간이 부족하여 추정치를 사용해야할 때가 많다
  * 추정치로 인해 발생하는 그래픽오류를 그래픽 아티팩트라고 하며 이를 완전히 극복할 수 있는 게임은 없다
### 폴리곤 
* 3D 오브젝트를 표현하는 방법은 다양하지만 게임에서는 주로 폴리곤(삼각형)을 이용해서 3D오브젝트를 표현함
  * 삼각형인 이유는? : 3개의 vertex로 표현할 수 있는 가장 간단한 다각형이기도 하고, 삼각형을 사용하면 모든 3D오브젝트를 빈틈이나 기타 변형 없이 모든 면을 채울 수 있음
* 메시 : 하나의 모델을 뜻함, 수많은 삼각형으로 이루어져 있음
* 모든 그래픽 라이브러리는 그래픽카드가 그려야 할 삼각형의 목록을 지정하는 방법을 지니고있고, 목록에 속한 삼각형을 그리는 방법에 관한 정보도 제공해야함.
## 좌표공간
* 좌표공간은 각 장면의 기준틀을 제공, 데카르트 좌표공간은 중앙이 원점이며 모든 위치는 중앙을 기준으로 함
* 다른 원점을 기준으로 하는 좌표곤간이 있을 수도 있음
* 3D 렌더링 파이프라인을 통해 3D모델을 2D모니터에 표시하려면 네 개의 주요 좌표공간을 거쳐야함
  * 모델공간
  * 월드공간
  * 뷰, 카메라공간
  * 투영공간
### 모델공간
* 모델의 모든 버텍스는 모델 자체의 원점을 기준으로 표현해야함
* 모델 공간의 원점은 모델의 중앙일 때가 많음. 그러나 인간형 모델은 두 발 사이가 원점이어야 다루기 쉬움
### 월드공간 
* 레벨을 제대로 로드하기 위한 새로운 좌표계
* 월드 공간의 원점은 게임 세계 전체의 원점이며 모든 오브젝트의 위치와 방향은 월드공간의 원점을 기준으로 함
* 메모리에 모델을 로드했을 때 모델의 모든 버텍스는 모델 공간을 기준으로 놓여있고, 이를 하나하나 직접 바꾸는 것은 어렵다
* 대신 그래픽 카드에 각 모델을 그릴 위치, 회전, 스케일 데이터를 전달하는 방법을 사용한다
* 이러한 추가 데이터를 만들기 위해 행렬을 이용, 행렬을 사용하려면 모델의 위치를 동차좌표라는 다른 형식으로 바꿔서 표현해야함
  * 동차좌표
    * 3D 공간에서 사용하는 4D 좌표, 네 번째 성분을 w성분이라고 함
    * w성분은 0 or 1, w=0이면 3D벡터를 나타내는 동차좌표, w=1이면 점을 나타내는 동차좌표라는 의미
    * 행렬을 사용해서 4D벡터 변환
    * <img src="01_4D_convert.jpg">
#### 변환행렬
* 정해진 방식으로 벡터나 점을 변경할 수 있는 행렬, 이를 사용하면 모델 공간 좌표를 월드 공간 좌표로 바꿀 수 있음
* 대부분 4X4 행렬이나, 신축행렬과 회전행렬은 필요에 따라 3X3 행렬로 사용하기도 함
* 신축행렬(scale matrix)
* 정해진 크기로 만들어진 모델을, 모든 버텍스에 적절한 신축행렬을 곱하여 배율을 늘림
* <img src="02_scale_matrix.jpg">
#### 이동행렬(translation matrix)
* 점의 위치를 정해진 양만큼 옮김. 벡터에는 적용할 수 없음
* 이동행렬의 역행렬을 구하려면 각 이동 성분의 기호를 반대로 바꿔줘야함
* <img src="03_translation_matrix.jpg">
#### 회전행렬(rotation matrix)
* 좌표축을 기준으로 벡터나 점을 회전시킬 수 있는 행렬
* 데카르트 좌표축마다 하나씩으로 총 3개
* 회전행렬을 이용한 회전 방식을 오일러 회전(Euler rotations)이라고 함
* <img src="04_rotation_matrix.jpg">
#### 다중변환 적용
*  원하는 월드변환 행렬을 얻으려면 여러 종류의 변환을 합쳐야 할 때도 있음
*  변환 행렬을 합치려면 그냥 곱하면 되나. 행렬의 곱셈은 교환법칙이 성립하지 않으므로 순서가 중요하다.
*  행 우선 표현일 때 일반적인 월드 변환 순서는 다음과 같다
*  월드변환 = 신축 X 회전 X 이동
### 뷰, 카메라공간
* 카메라의 눈에 비치는 공간을 뷰 공간 or 카메라 공간이라고 함
* 월드 공간에 놓인 모델을 카메라에 관한 좌표 공간으로 변환할 방법을 그래픽카드에 알려줄 행렬이 필요함. 이럴 때 뷰 행렬(look-at matrix)을 사용
* 행 우선 왼손좌표계일 때 뷰 행렬은 다음과 같다
* <img src="05_lookat_matrix.jpg">
* L : 왼쪽 또는 x축 방향, U : 위쪽 또는 y축 방향, F : 앞쪽 또는 z축 방향, T : 이동을 나타내는 벡터
* 뷰 행렬을 만들려면 방금말한 네 벡터를 계산해야 함. 대부분의 3D라이브러리는 뷰행렬을 자동으로 계산해주는 함수를 제공함
* 뷰행렬을 구성하는데 필요한 벡터를 계산하려면 카메라의 위치에 해당하는 눈(eye), 카메라가 바라보는 대상의 위치(target), 카메라의 위쪽을 가리키는 벡터(up)
  * 이렇게 총 3개의 입력값이 필요, 카메라의 위쪽을 가리키는 벡터와 월드의 위쪽을 가리키는 벡터가 일치할 때도 있지만, 항상 그렇진 않다.
* 3개의 입력값으로 L, U, F, T 구하는 코드
```
function CreateLookAt(Vector3 eye, Vector3 target, Vector3 Up) {
  Vector3 F = Normalize(target - eye) // 대상의 위치에서 카메라의 위치를 뺀 후 정규화(방향이 중요)
  Vector3 L = Normalize(CrossProduct(Up, F)) // 카메라 위쪽과 대상을 바라보는 위치를 외적 후 정규화
  Vector3 U = CrossProduct(F, L) // F와 L을 외적
  Vector3 T
  T.x = -DotProduct(L, eye)
  T.y = -DotProduct(U, eye)
  T.z = -DotProduct(F, eye) // x,y,z 요소를 각각 L, U, F와 내적후 -을 곱
end
```
### 투영 공간(projection space)
* 3D 장면을 2D 좌표공간으로 투영한것. 직교투영과 원근투영이 있음
#### 직교투영(orthographic projection)
  * 월드 전체를 원근감 없이 2D 이미지에 눌러담는 방식. 순수 2D게임은 직교투영을 사용한다고 보면 된다
  * 직교투영행렬, 필요한 매개변수는 뷰의 폭, 뷰의 높이, 카메라의 눈과 가까운 평면 사이의 최단거리, 먼 평면 사이의 최단거리 4개
  * <img src="06_orthographic.jpg">
#### 원근투영(perspective projection) 
  * 카메라에서 먼 오브젝트가 가까운 오브젝트보다 작게 보임
  * 원근투영행렬, 시야각(FOV, field of view)라는 매개변수가 하나 더 필요함. 카메라의 눈을 통해 한 번에 볼 수 있는 각도를 의미 
  * 원근 투영 행렬을 곱하고 나면 버텍스의 w 성분이 1이 아닐 것이다.
  * 변환한 버텍스의 각 원소를 새로운 w성분 값으로 나눠주면 카메라와의 거리에 반비례해 오브젝트의 크기가 줄면서 w 성분이 다시 1로 바뀐다
    * 이 과정을 원근분할(perspective divide)라고 함
    * <img src="07_perspective.jpg">
* 두 투영 모두 가까운 평면과 먼 평면을 지님. 가까운 평면은 보통 카메라와 아주 가까우며 카메라와 가까운 평면 사이의 영역은 화면에 그려지지 않는다.
  * 오브젝트와 카메라가 너무 가까워지면 일부가 사라져서 속 빈 인형처럼 보이는 이유가 그것
  * 마찬가지로 먼 평면 너머는 화면에 그려지지 않음
## 조명과 셰이딩
* 지금까지 버텍스의 목록과 함께 GPU에 전달할 월드 변환 행렬, 뷰행렬, 투영행렬등을 통해 3D로 만든 와이어프레임을 2D색상버퍼에 흑백으로 그릴 수 있다.
* 하지만 흑백 와이어프레임만으로는 게임을 만들기 어렵다. 게임의 구색을 맞추려면 뻥 뚫린 삼각형 정도는 채워야한다. 색상, 텍스쳐, 조명도가 필요하다
* 색상
  * RGB를 통해 색상을 표현하는 가장 흔한 방법은 각 색상에 8bit를 할당 하지만 3D그래픽에서는 0.0~1.0의 부동소수점 표현을 사용한다
  * 게임에 따라 알파값이라고 하는 네 번째 요소가 필요할 수 있는데 이는 투명도를 의미한다. RGBA를 모두 지원하며 각 요소가 8bit라면 픽셀하나가 32bit를 차지한다
* 버텍스 속성 
  * 모델에 색상을 적용하려면 각 버텍스에 버텍스 속성(vertex attribute)이라는 추가 정보를 저장해야함
  * 버텍스 속성이 많아지면 모델을 사용할 때 메모리에 부담이 커진다.
  * 버텍스 속성에 포함된 텍스처 좌표는 텍스처의 UV좌표계와 일치하는 부분을 매핑한다(<a href="https://woodorl.tistory.com/40?category=268475">참고링크</a>)
    * UV좌표계는 텍스처의 좌표를 표현하는 좌표계로 U가 x, V는 y를 의미
  * 텍스처만 사용해도 다채로운 장면을 만들 수 있으나 빛과 그림자가 없으므로 사실적인 면은 떨어짐
  * 대부분 조명모델은 버텍스법선(vertex normal)이라는 버텍스 속성을 사용함. 하지만 버텍스는 하나의 점인데 법선을 가질 수 있을까?
    * 조명모델이란 광원에서 각 점까지의 조도를 계산하는 방법. 크게 경험모델과 물리모델로 나뉨
      * 경험모델
        * 관찰의 결과를 근삿값으로 수식화해서 만든 조명모델
      * 물리모델
        * 빛과 물질의 실제 물리적 상호작용을 바탕으로 만든 조명모델
  * 버텍스의 법선을 정하는 방법은 여러개가 있다
    * 버텍스를 포함하고있는 모든 삼각형의 법선을 평균하는 방법
      * 둥글둥글한 모델이라면 괜찮지만 모서리가 뾰족한 모델이라면 적절하지 않은 방법
      * 정육면체의 경우 여덟모서리를 각각 세개의 버텍스로 표현해야함
      * 삼각형은 외적의 수행 순서에 따라 두 개의 법선을 지닌다는 점을 떠올리고 두르기 순서를 게임전체에서 일관적으로 쓰이도록 해야함에 유의
    * 카메라를 등진 삼각형을 아예 그리지 않는 뒷면 제거(back-face culling)는 렌더링 성능을 높일 수 있는 기법 중 하나
### 조명
  * 3D게임에 널리 쓰이는 조명 중에는 장면 전체에 영향을 미치는 조명도 있고, 조명주위에만 영향을 미치는 조명도 있음
  * 주변 광(ambient light)
    * 장면 안의 모든 오브젝트에 균등하게 작용하는 빛. 주변 광의 광량은 시간대에 따라 다르게 설정할 수 있음
    * 주변 광은 전체적으로 똑같은 광량을 제공하기 때문에 오브젝트의 앞면이든 옆면이든 딱히 다르게 작용하지 않음
  * 방향 광(direction light)
    * 정확한 위치는 모르지만 특정한 방향에서 들어오는 빛
    * 주변 광과 마찬가지로 장면 전체에 영향을 미치지만 특정한 방향에서 들어오므로 한쪽 면을 밝게 비추고 반대편을 어둡게 만드는 효과가 있음
  * 포인트 라이트
    * 정해진 위치에 놓여서 사방으로 빛을 발하는 조명
    * 오브젝트의 한쪽 면만을 밝게 비춘다
    * 광원과의 거리에 따라 광량을 지정하는 감쇠반경(falloff radius)라는 변수를 추가해야 함
  * 스포트라이트
    * 포인트라이트와 비슷하나 모든 방향을 비추지 않고 원뿔 형태로 비추는 조명
    * 원뿔형태의 스포트라이트를 만들려면 매개변수로 각도가 꼭 필요
  * 퐁 반사 모델(Phong reflection nodel) 
    * 조명이 장면 안의 오브젝트에 미치는 영향을 계산하는데 사용하는 양방향 반사 분포함수(BRDF, bidirectional reflectance distribution function)중의 하나
    * 뒤에 나오는 퐁 셰이딩과는 다른 개념이라는 것을 인지할 것
  * 빛의 2차 반사를 고려하지 않으므로 지역 조명 모델(local lighting model)로 간주
    * 각 오브젝트는 다른 오브젝트와 상관없이 장면에 홀로 놓인듯이 조명 효과를 받는다는 의미
    * 예시)흰 벽에 붉은 조명을 비추면 벽에서 반사된 붉은 빛이 방 전체를 붉게 채우지만 지역 조명모델에서는 이런 일이 일어나지 않음
  * 퐁 반사 모델에서 빛은 주변 광, 난반사, 정반사 세 가지 요소로 뚜렷하게 나뉨
  * 세 요소 모두 오브젝트의 색상과 오브젝트에 영향을 주는 조명의 색상을 함께 고려함
  * 주변 광
    * 장면의 전체적인 밝기와 관련있음, 앞서 설명한 주변 광 조명을 그대로 쓸 수도 있음
    * 전체 화면에 균일하게 작용하기 때문에 광원, 카메라의 위치와 무관함
  * 난반사(diffuse)
    * 오브젝트의 표면에 부딪혀 나온 일차적인 빛의 반사
    * 오브젝트에 작용하는 방향 광이나 포인트, 스포트라이트의 영향을 받음
    * 난반사 요소를 계산하려면 오브젝트의 표면에서 광원으로 향하는 벡터는 물론, 표면의 법선도 필요, 하지만 주변 광 요소와 마찬가지로 카메라의 위치에 영향을 받지 않음
  * 정반사(specular)
    * 표면의 하이라이트를 나타냄. 광택을 낸 금속처럼 반사도가 높은 오브젝트는 검은색 무광페인트를 칠한 오브젝트보다 하이라이트가 더 많을 것
    * 난반사 요소와 마찬가지로 정반사 요소는 표면의 법선과 함께 광원의 위치에 영향을 받음, 하지만 뷰 벡터의 위치에 따라 하이라이트가 바뀌므로 카메라의 위치에도 영향을 받는다는 차이가 있음
#### 퐁 반사 모델의 계산코드, 루프를 통해 표면에 영향을 주는 장면 내의 조명을 전부 확인하면서 표면의 최종 색상을 구하는 계산을 수행해야함
```
//Vector3 N = 표면의 법선
//Vector3 eye = 카메라의 위치
//Vector3 pos = 표면의 위치
//float a= 반사도(광택) 
Vector3 V = Normalize(eye - pos) // 표면에서 카메라로 향하는 벡터
Vector3 Phong = AmbientColor
foreach Light light in scene
  if light affects surface
    Vector3 L = Normalize(light.pos - pos) // 표면에서 광원으로 향하는 벡터
    Phong += DiffuseColor * DotProduct(N, L)
    Vector3 R = Normalize(Reflect(-L, N)) // N에 관한 -L의 반사 벡터
    Phong +- SpecularColor * pow(DotProduct(R, V), a) // R,V를 내적한 값을 a 만큼 제곱
  end
end
```
### 셰이딩 
* 삼각형의 표면을 채우는 방법으로 반사 모델과는 다른 개념
* 가장 기본적인 형태는 삼각형 전체에 하나의 색을 적용하는 플랫 셰이딩.
  * 이는 보통 삼각형의 중심을 기준으로 삼각형마다 한 번 씩 반사 모델을 계산한 뒤, 계산의 결과로 나온 색을 삼각형에 반영
  * 간단한 장면이라면 몰라도 플랫 셰이딩으로 볼 만한 장면을 만들기는 힘듬
* 고러드 셰이딩(Gouraud shading)
  * 버텍스마다 한 번씩 반사모델을 계산
  * 하나의 삼각형을 이루는 버텍스의 색상이 각각 다를 수 있음
    * 그럴 때는 각 버텍스의 색상을 섞어서 삼각형의 나머지 부분을 채운다
    * 예시)한 버텍스가 빨간색이고 다른 버텍스가 파란색이면 두 버텍스 사이의 색상은 서서히 빨강에서 파랑으로 바뀜
  * 몇 가지 문제점이 존재
    * 셰이딩의 품질이 모델의 폴리곤 수와 직결함. 폴리곤 수가 적은 모델은 정반사 하이라이트의 크기가 작으면 밴딩이라는 줄무늬가 나타남
    * 폴리곤 수가 많은 모델에 고러드 셰이딩을 적용하면 보기좋은 결과를 얻을 수 있으나 폴리곤 수가 늘어나는만큼 메모리의 부하가 증가
    * GPU의 성능이 좋아진 요즘은 찾기 힘든 기술
* 퐁 셰이딩
  * 삼각형의 모든 픽셀에서 반사모델을 계산함. 이렇게 계산하려면 삼각형의 표면 전체에 걸쳐 버텍스 법선을 보간해야함. 그 후 모든 픽셀에서 보간의 결과를 법선으로 사용해서 조명을 계산
  * 고러드 셰이딩의 연산량보다 훨씬 많음, 조명의 수가 많은 장면에서는 연산량이 더더욱 많아지나 최신 하드웨어는 쉽게 처리할 수 있는 수준임
  * 일종의 픽셀당 조명이라 볼 수 있음. 고러드 셰이딩보다 결과가 훨씬 매끄러우며 명암도 뚜렷
  * 퐁셰이딩을 사용했더라도 폴리곤 수가 적은 오브젝트는 가장자리에서 확연히 티가남
#### 가시성 
* 메시, 좌표공간행렬, 조명반사모델, 셰이딩까지 마쳤다면 화면에 표시할 오브젝트와 표시하지 않을 오브젝트를 가리는 일을 해야함
* 2D 게임과는 다르게 3D 게임에서는 카메라가 바라보는 시점이 바뀌므로 화가알고리즘을 재검토할 필요가 있음
* 이미 그려진 픽셀에 한 번 더 그려지는 오버드로우가 매우 많이 발생할 수 있음
* Z버퍼링
  * 렌더링 과정에 Z 버퍼라는 별도의 메모리 버퍼를 사용하는 기법
  * 색상 버퍼와 마찬가지로 장면에 들어있는 각 픽셀의 데이터를 저장함
  * Z버퍼는 깊이 버퍼라고도 하는데 색상 정보를 저장하는 색상 버퍼와 달리 픽셀과 카메라의 거리를 나타내는 깊이를 저장함
  * Z버퍼링을 사용해서 프레임을 그릴 때는 먼저 모든 픽셀의 깊이를 무한대로 설정함
    * 그런 다음 렌더링 과정에서 픽셀을 그리기 전에 해당 픽셀의 깊이를 계산
    * 계산한 픽셀의 깊이 값이 현재 Z버퍼에 들어있는 깊이 값보다 작으면 픽셀을 그리고 새로운 깊이 값을 Z 버퍼에 기록
  * 따라서 프레임마다 처음 그려지는 오브젝트는 항상 색상버퍼와 Z버퍼에 픽셀의 색상과 깊이 정보를 모두 지님
  * 하지만 두 번째 오브젝트를 그릴 때는 이미 화면에 그려진 픽셀보다 거리가 먼 픽셀은 그리지 않고 넘어감
#### Z버퍼링 코드 
```
// zBuffer[x][y]는 해당 픽셀의 깊이 값
foreach Object o in scene
  foreach Pixel p in o
    float depth = calculate depth at p
    if zBuffer[p.x][p.y] > depth
      draw p
      zBuffer[p.x][p.y] = depth
    end
  end
end 
```
  * Z버퍼링을 사용하면 장면을 그리는 순서가 임의로 바뀔 수 있으며, 투명도를 지니는 오브젝트만 없다면 모든 오브젝트가 제대로 그려짐
  * 먼 오브젝트를 먼저 그리면 프레임마다 오버드로우가 발생해서 성능에 악영향을 줄 수 있으믈 가까운 오브젝트를 먼저 그려야 오버드로우가 발생하지 않음
  * Z버퍼링은 프레임마다 장면을 깊이에 관해 다시 정렬할 필요가 없으므로 성능을 큰 폭으로 개선할 수 있음
  * 색상버퍼와 마찬가지로 Z버퍼 역시 각 픽셀에 할당할 비트 수를 결정해야하는데 적어도 16bit이상이어야 무난하다고 함
    * 하지만 무턱대고 메모리를 아끼려다보면 다른 오브젝트에 속한 두 픽셀이 아주 가까이 붙어있고 카메라의 눈에 한 픽셀로 보일 만큼 멀다면 
    * 프레임이 바뀔때마다 앞뒤 픽셀이 바뀌며 깜박거리는 Z 경합(z-fighting)이라는 부작용이 발생
    * 이로 인해 요즘은 24bit, 32bit z버퍼를 사용
  * 문제가 없지는 않으므로 요즘 상용게임은 더 복잡한 선별(culling)알고리즘, 차폐(occlusion)알고리즘을 사용하여 해당 프레임에 그릴 필요없는 오브젝트를 제거해버림
    * 이런 알고리즘을 이해하려면 BSP,  포털 등을 잘 알아야함
## 월드 변환 재검토
* 오일러 각을 사용해서 회전을 구현하려면 몇 가지 심각한 문제가 발생
* 오일러 각의 특성상 임의의 축을 설정해서 한 번에 회전을 수행할 수 없어, 여러 번의 회전을 조합해서하므로 계산이 매우 까다로움
* 좌표축을 기준으로 오일러 회전을 수행하면 다른 좌표축의 방향이 함께 바뀌는 문제도 있음
  * 예시)z축을 기준으로 90도 회전하면 x축과 y축이 하나로 합쳐져 둘 중 한 축을 기준으로 하는 회전을 모두 잃음(gimbal lock)
* 마지막으로 두 방향 사이를 원만하게 보간하는 문제가 남아있음
  * 예시) 화살표를 사용해서 다음 목적지를 가리키는 기능이 있는 게임을 가정
  * 목적지에 도착하고 나면 화살표로 다음 목적지를 가리켜야하나 화살표가 순식간에 돌아가면 보기에 안좋으므로 1~2초 정도 안에 매끄럽게 돌려야함
  * 오일러 각을 사용하면 회전 자체는 구현할 수 있더라도 보기 좋게 보간하는 것이 어려움
* 사원수(quaternion)
  * 오일러 회전을 대체하여 게임프로그래밍에서 단순히 임의의 축을 기준으로 하는 회전을 구현하는 방식
  * 사원수를 사용하면 회전축을 x,y,z축으로 한정하지 않고 마음대로 정할 수 있음
  * 또한 사원수는 두 사원수 사이를 쉽게 보간할 수 있다는 장점이 있음. 두 가지 종류의 보간법이 존재
    * 기본적인 선형 보간법(lerp)
    * 구면 선형 보간법(slerp)
      * lerp보다 더 정확하지만 시스템에 따라 계산이 좀 더 길어질 수 있음
  * 사원수의 정보를 저장하는데 필요한 부동소수점값은 4개뿐이므로 메모리의 사용량이 줄어듬
  * 오브젝트의 이동과 신축을 각각 3D 벡터 하나와 부동소수점 하나로 저장했듯이 오브젝트의 방향도 사원수 하나로 저장할 수 있음
  * 사실상 게임에서는 단위 사원수(unit quaternions)를 사용, 단위 벡터처럼 크기가 1인 사원수를 말함
  * 사원수는 벡터와 스칼라 성분을 모두 지님
  * <img src="/08_unit_quaternions.jpg">
  * 회전축을 정규화해야 하는 것에 유의하지 않으면 회전과 동시에 오브젝트가 불규칙하게 늘어남
  * 처음 방향과 새로운 방향의 외적을 구하면 회전축이 정해지며, 회전할 각도는 내적을 사용해서 구할 수 있다. 이를 바탕으로 사원수를 생성하여 회전
  * 사원수의 회전은 연속으로 수행할 수 있으며, 연속으로 수행하려면 두 사원수를 곱해야하는데, 수행 순서와 반대로 곱해야 한다
    * 사원수를 곱하려면 그라스만 외적(Grassmann product)을 사용해야함
    * <img src="/09_grassmann_product.jpg">
  * 단위 사원수는 벡터 성분의 부호만 바꿔주면 역수를 구할 수 있음. 이를 켤레(conjugate)사원수라고 함
  * 역이 존재하므로 항등 사원수도 존재함
     * <img src="/10_I_quaternions.jpg">
  * GPU는 여전히 행렬 형태의 월드변환 행렬을 요구하므로 사원수를 행렬로 변환해야할 때가 오는데, 3D수학라이브러리는 이를 수행하는 함수가 구현되어있음
## 3D 게임오브젝트 표현 
* 월드변환하려면 데이터를 저장해둔 후 렌더링 코드로 월드변환행렬 정보를 보내야할 때 이 데이터로 임시 행렬을 만들어서 보낼 수 있음
* 즉 코드 내에서 게임오브젝트의 위치를 업데이트 해야한다면, 행렬 전체를 바꿀 필요 없이 위치벡터만 바꾸면 됨
#### 코드 
```
class 3DGameObject 
  Quaternion rotation
  Vector3 position
  float scale
  function GetWorldTransform() // 신축, 회전, 이동 순서를 지킬 것
    Matrix temp = CreateScale(sclae) * CreateFromQuaternion(rotation) * CreateTranslation(position)
    return temp
  end
end
```
