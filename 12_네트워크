프로토콜
  패킷은 네트워크를 통해 전송할 디지털 봉투라 볼 수 있음
    주소와 기타 관련 정보를 포함하는 헤더와 전송해야할 실제 데이터인 페이로드로 이루어짐
  프로토콜은 패킷의 구성방법과 패킷을 전송할 때 해야할 일을 정의함
  최신 네트워크 게임은 대개 TCP와 UDP 중 하나의 프로토콜을 사용함
  게임 플레이와 상관없는 기능에 한해 ICMP프로토콜을 사용하는 게임도 있음
IP(Internet Protocol)
  인터넷을 통해 데이터를 전달하려면 반드시 따라야 하는 프로토콜
  ICMP, TCP, UDP 등 앞으로 소개될 모든 프로토콜은 기본적으로 IP를 준수해야함
  로컬 네트워크로 데이터를 전송할 때도 마찬가지인데, 요즘 네트워크 구성에서는 로컬 네트워크 내의 기기를 식별할 때 사용하는 로컬 주소를 IP를 통해 할당받기 때문
  IPv4 헤더
  <img src="/01_IP_header.jpg">
  IPv4 주소는 총 32비트로 약 40억개의 주소를 조합할 수 있음
    요즘 40억개는 그리 충분한 숫자가 아님
  이러한 문제 때문에 IPv6가 등장
    총 128비트로 2^128개라는 주소를 만들 수 있으며 헤더가 IPv4와 다름
    이이는 공식적으로 2012년에 출범했으나 아직 IPv4를 오나전히 대체하지 못하여 IPv4와 IPv6을 적절히 함께 사용함
    하지만 플랫폼과 ISP가 지원한다면 IPv6로 전환하기를 권장
ICMP(Internet Control Message Protocol)
  많은 데이터를 전송할 목적으로 만들어진 프로토콜이 아님
  즉, 게임 데이터를 전송하는 용도로는 사용할 수 없음
  ICMP의 특징 중 하나인 에코는 멀티플레이 게임을 프로그래밍할 때 활용할 수 있음
  ICMP의 에코 요청과 에코 응답을 사용하면 지정한 주소에 패킷을 보낸 뒤에 즉시 되돌려 받을 수 있음
  이런 에코 기능은 패킷이 두 컴퓨터 사이를 왕복하는 시간을 측정할 때 효과를 발휘
  플레이어가 접속할 수 있는 서버가 여러 대인 상황일 때 패킷의 왕복 시간인 지연시간(latency)를 알 수 있다면 매우 유용
  모든 서버를 대상으로 지연 시간을 측정한 뒤에 지연 시간이 가장 짧은 서버를 선택할 수 있기 때문
  이렇게 정해진 주소에 관한 지연 시간을 측정하는 과정을 핑(ping)이라고 함
  에코 요청을 받은 수신자는 받은 패킷의 페이로드를 그대로 응답 패킷에 실어서 돌려 보냄
  ICMP헤더는 타임스탬프 정보가 없으므로 송신자는 에코 요청을 전송하기 전에 현재 타임스탬프를 vpdlfhemdp wjwkdgotj qhsodigka
  에코 응답을 받은 송신자는 요청할 때 페이로드에 실어 보냈다가 되돌아온 타임스탬프와 현재 타임스탬프를 비교해서 패킷의 왕복 시간을 계산할 수 있고 이를 반복하여 평균 응답시간을 얻음
  ICMP패킷의 체크섬은 전송 과정에서 패킷의 손실이 일어났는지 확인하는데 사용
    ICMP의 헤더와 페이로드 데이터값을 바탕으로 만들어짐
  수신자가 받은 ICMP패킷이 체크섬과 일치하지 않는다면 해당 패킷은 버려짐
  체크섬은 패킷 내의 모든 데이터를 바탕으로 하므로 전송할 준비가 끝난 패킷을 대상으로 계산해야함
  식별자와 일련번호값은 에코 요청을 특정함. 식별자는 대개 기기마다 고유한 값이고 일련변호는 새로 에코 요청을 보낼 때마다 늘어나는 값이기 때문
  <img src="/02_ICMP_header.jpg">
TCP(Trasfer Control Protocol)
  게임에서 네트워크를 통해 데이터를 전송할 때 사용하는 두 가지 방법 중의 하나
  TCP는 모든 패킷의 전송 순서를 보장하는 연결중심프로토콜
  전송 순서를 보장한다는 점이 좋아보일 수 있으나 일반적으로 게임에서 TCP는 조금 뒤에 소개할 UDP만큼 많이 쓰이지는 않음
  두 컴퓨터가 데이터를 주고받으려면 먼저 연결을 맺어야함
  연결을 맺으려면 핸드셰이킹이라는 과정을 거쳐야함
  TCP연결을 맺고 나면 두 컴퓨터는 데이터를 주고받을 수 있음
  TCP에서 패킷의 전송을 보장하는 방법은 수신자가 수신에 관한 확인응답(ACK, Acknowledgement)을 보내는 것
  송신자는 타임아웃이 지나도록 수신자의 확인 응답을 받지 못하면 패킷을 다시 전송함
  <img src="/03_TCP_handshaking.jpg">
  TCP는 모든 패킷으 ㅣ전송 자체를 보장할 뿐 아니라 전송 순서도 보장함
  다음과 같은 오류가 생기지 않음
  <img src="/04_TCP_failed.jpg">
  게임에서는 전송 순서의 보장이 불필요한 병목 현상을 일으킬 때가 많음
  위의 예시에서 A,B,C 순서로 위치에 관한 정보가 업데이트되어야하지만 C의 정보를 받았음에도 B의 정보를 기다리는 것은 바람직하지 않음
  TCP의 유용한 특징 중 하나는 패킷의 최대 전송단위(MTU, Maximum Transmission Unit)보다 큰 패킷을 전송하려 하면 OS가 알아서 적절한 크기의 패킷으로 나눠준다는 것
  게임 중에는 큰 데이터를 전송해야 할 상황이 거의 없으나, 예시)커스텀 맵을 지원하는 게임에서 해당 맵이 없는 플레이어가 새로 게임의 합류하기위해 맵을 다운받을 때 자동 패킷분할은 유용하게 사용됨
  실제로 게임을 플레이하는 내내 TCP를 사용해야 하는 게임은 별로 없으나 턴 방식의 게임에는 TCP가 알맞음
  WOW는 모든 데이터 전송에 TCP를 사용함. 하지만 실시간으로 진행해야 하는 FPS나 액션 게임은 게임의 성능에 악영향을 줄 수 있으므로 보통 TCP/IP를 사용하지 않음
  <img src="/04_TCP_header.jpg">
  헤더에서 꼭 언급해야 하는 필드가 하나 있는데 이는 포트번호
  네트워크를 통해 패킷을 보낼 때는 포트 번호가 우편함의 역할을 함
  IANA에서 권고하는 포트번호 할당에 관한 목록이 있으나 이는 권고안일 뿐 절대적으로 따를 필요는 없음. 선택할 수 있는 포트의 수는 대략 65000개 이므로 마음 껏 사용하면 됨
  게임은 다른 프로그램에 잘 사용하지 않는 포트를 선택해야함
  발신지 포트와 목적지 포트가 같을 필요가 없다는 점에 유의
UDP(User Datagram Protocol)
  비연결 방식의 신뢰할 수 없는 프로토콜
  즉 먼저 연결을 맺지 않아도 원하는 목적지로 UDP 패킷 전송을 시작할 수 있다는 뜻
  패킷의 전송 여부나 전송 순서를 보장하지 않으며 수신자가 확인 응답을 보내는 기능도 없음
  <img src="/05_UDP_Header.jpg">
  UDP도 TCP와 마찬가지로 약 65000개의 포트를 지원하는데 이는 TCP포트와 별개이므로 같은 포트를 사용해도 충돌이 발생하지 않음
  UDP 전송은 TCP전송보다 훨씬 효율적일 수 있으나 패킷을 받았는지 확인할 방법이 없으므로 문제가 생길 수 있음
  예시)적의 위치 같은 데이터는 한두 번 못 받아도 게임에 큰 영향을 미치지 않지만, 게임의 상태를 일관성있게 유지하려면 꼭 받아야하는 데이터가 있음
    멀티플레이 FPS의 경우 총을 쏘는 경우는 서버와 다른 플레이어가 반드시 수신해야할 중요한 데이터에 해당
  중요한 데이터는 TCP로 전달하고, 중요하지 않은 데이터는 UDP로 전달하면 어떨 까?
    INET 97학위 논문에 의하면 TCP의 전송보장 시스템과 UDP를 동시에 실행할 경우, 제대로 도착하지 않는 UDP패킷의 수가 증가한다고 함
    더 큰 문제는 위치 데이터가 크게 중요하지 않아서 UDP로 전달한다고 해도 여전히 패킷의 순서를 알 방법이 필요하다는 점
    순서를 모르는 채 위치 B를 위치 C 다음에 수신하면 플레이어는 뜬금없이 이미 지나왔어야 할 위치 B로 이동해버림
  UDP를 사용하는 게임은 대부분 별도의 신뢰성 레이어를 추가하는 방식으로 이런 문제를 해결
  이런 레이어는 UDP의 데이터 필드 앞부분에 추가할 수 있음
    별도의 프로토콜 헤더를 추가한다고 생각하면 이해가 쉬움
    기본적인 신뢰성을 보장하려면 최소한 패킷의 번호를 나타내는 일련번호와 확인 응답으로 사용할 비트 필드가 필요
    비트 필드를 사용하면 패킷마다 확인 응답을 따로 보내지 않고 하나의 패킷에 여러 패킷의 확인 응답을 실어서 한 번에 보낼 수 있음
    또한 이렇게 별도의 레이어를 추가하면 신뢰성 또는 순서가 필요없는 데이터일때 레이어를 추가하지 않고 그냥 보낼 수 있는 융통성이 존재
    신뢰성 레이어의 구체적인 구현 방법은 책의 범위를 벗어남
    UDP는 실시간 게임에 주로 쓰이는 프로토콜, FPS, 액션, RTS, 분 초를 다투는 네트워크 게임은 거의 모두 UDP를 사용
    이러한 이유로 RakNet같은 게임전용 네트워크 미들웨어는 거의 모두 UDP만 지원함
    
네트워크 토폴로지 
  네트워크 게임 세션 내의 여러 컴퓨터를 서로 연결하는 방식을 의미
  토폴로지를 구성하는 방법은 다양하지만 대부분의 게임은 서버/클라이언트 or 피어 투 피어(P2P) 두 모델 중 하나를 지원
서버/클라이언트 
  서버라고 하는 컴퓨터 한 대가 클라이언트라고 하는 컴퓨터 여러대와 통신하는 방식
  서버는 모든 클라이언트와 통신해야 하므로 대역폭과 처리 능력이 클라이언트보다 높아야함
  허브 앤 스포크(hub and spoke)모델이라고도 불림
  <img src="/06_server_client.jpg">
  요즘 네트워크 게임에서 가장 많이 쓰이는 토폴로지
  전형적인 서버/클라이언트 모델에서 모든 서버는 권한 보유(authoritative)서버로 여겨짐
  즉 클라이언트의 주요 동작을 서버가 대부분 확인해야함
  예시)다른 플레이어에게 공을 던질 수 있는 네트워크 피구게임
    피구공에 맞은 플레이어는 경기장에서 나가야하는데, 서버가 권한을 보유하고 있으므로 플레이어가 공을 던지려할 때 클라이언트는 공을 던지는 행동이 올바른 행동인지 확인하는 요청을 서버로 보냄
    요청받은 서버는 피구 공의 궤적을 계산하여 프레임마다 피구 공에 맞은 클라이언트가 있는지 확인, 공에 맞은 클라이언트가 있다면 서버는 해당 클라이언트를 서버에서 추방
  이런 과정을 서버가 확인하는 이유는 두가지
    첫 번째. 서버가 모든 클라이언트의 최신 위치정보를 지니고 있기 때문
    한 클라이언트가 공을 던져 분명히 다른 클라이언트르 맞췄다고 생각했는데 타겟의 위치 정보가 최신 정보가 아니라면 실제로는 공이 빗나가는 상황이 발생
    게다가 피구 게임에서 클라이언트가 서버의 확인 없이 다른 플레이어를 내보낼 수 있다면 치트(cheat)프로그램을 만들었다는 가능성이 있음
  서버가 권한을 보유해야 한다는 특성때문에 서버/클라이언트용 게임 코드 구현은 싱글플레이 게임보다 훨씬 복잡함
  구현 방식이 완전히 달라지므로 멀티플레이와 싱글플레이를 함께 지원하는 게임을 만들어야할 때 가장 좋은 방법은 싱글플레이를 특별한 형태의 멀티플레이처럼 구현하는 것(id 소프트웨어 엔진 등이 지원)
  즉 싱글플레이 모드를 한 컴퓨터 안에서 서버와 클라이언트를 동시에 실행하는 방식으로 만든다는 의미
  싱글플레이를 특별한 형태의 멀티플레이로 만들 때의 장점은 싱글플레이용 게임 플레이 코드를 멀티플레이 게임에서 그대로 쓸 수 있다는 점
  이렇게 구현하지 않으면 네트워크 프로그래머는 클라이언트가 권한을 보유하는 방식으로 동작하는 게임 플레이 코드를 서버가 권한을 보유하는 방식을 바꾸느라 큰 시간을 낭비해야함
  다시 피구 게임 예제로 돌아가서 플에이어가 타겟의 앞쪽을 겨눠서(예측)던질 수 있게 하고 싶다고 가정
  그러려면 상대 플레이어가 이동하고 있는 방향을 알아낼 방법이 필요.
  모든 상황이 좋아서 클라이언트가 1/4초마다 서버에서 보내는 상대 플레이어의 위치 정보를 수신할 수 있고 클라이언트는 서버에서 새로운 위치데이터를 받았을 때만 상대 플레이어의 위치를 업데이트
    즉 상대 플레이어가 1/4초마다 새로운 위치로 순간이동 한다는 의미. 상대방을 제대로 조준하기가 쉽지 않을 것
  이런 문제를 해결하려면 클라이언트는 서버에서 다음 업데이트 정보가 올 때까지 벌어질 수 있는 일을 추측해야함, 일종의 클라이언트 예측
  업데이트가 충분히 자주 온다면 클라이언트가 상대 플레이어의 위치를 정확히 표시할 수 있겠지만 네트워크 문제로 업데이트가 자주 오지 않으면 클라이언트 예측의 정확성이 떨어짐
  위치에 관하 ㄴ최종 권한은 서버가 가지고 있으므로 클라이언트는 자신의 예측과 실제로 서버에서 수신한 위치와의 차이를 알아서 바로잡아야함
  이 개념을 확장하여 로컬에서 수행하는 동작에도 적용할 수 있음
    플레이어가 피구 공을 던지려고 스페이스 바를 누르는 즉시 공을 던지는 애니메이션을 보여준다고 가정
    이때 클라이언트가 피구공을 던져도 좋다는 서버의 확인을 기다려야 한다면 게임의 반응이 느려보일 수 있음
    해결 방법은 서버에서 실제로 공을 던질 수 있는지 확인하는 동안 로컬 클라이언트가 일단 피구 공을 그려버리는 것
    물론 던질 수 없는 상황이라는 판정이 나면 클라이언트가 알아서 문제를 바로 잡아야함
    적절한 동기화가 있다면 피구 공을 던질 때 매우 빠르게 반응하는 듯한 느낌을 줄 수 있음
  서버/클라이언트 모델은 매우 인기좋은 모델이나 생각해야할 문제가 몇가지 있음
  한 컴퓨터 안에서 서버와 클라이언트를 동시에 실행할 수 있는 게임이라면 호스트 어드벤티지(host advantage)가 발생할 가능성이 있음
    서버와 클라이언트를 함께 실행한 플레이어가 있을 때 서버가 이 플레이어의 동작을 더 빨리 처리해서 불공평한 상황이 벌어지는 문제
  또한 서버 고장으로 모든 클라이언트의 연결이 끊어지면 게임이 즉시 끝나버린다는 문제가 존재
  한 클라이언트에서 심각한 네트워크 지연이 발생해도 다른 플레이어에게 큰 영향을 주지 않는다는 장점 존재
  호스트때문에 벌어지는 문제를 방지하려고 아예 전용 서버(dedicated servers)만 지원하는 서버/클라이언트 게임이 많음
    이는 서버의 설치비, 운용비가 많이 들어간다는 단점이 존재
피어 투 피어(P2P)
  <img src="/07_P2P.jpg">
  모델의 각 클라이언트는 모든 클라이언트와 연결을 맺음. 즉 모든 클라이언트의 성능과 대역폭이 어느 정도 균형을 이뤄야함
  전체적인 권한을 보유하는 클라이언트가 없으므로 각 클라이언트가 자신의 행동에 관한 권한을 지니거나 각 클라이언트가 다른 클라이언트에 관한 권한을 지니거나,
  또는 각 클라이언트가 게임 세계 전체를 시뮬레이트 해야함
  P2P모델이 주로 쓰이는 장르는 RTS이며 약 150~200ms정도의 '턴'단위로 네트워크를 업데이트하는 락스텝(lockstep)모델이 많이 쓰임
  락스텝 모델은 사용자의 입력이 발생하면 해당 명령을 큐에 차곡차곡 저장했다가 턴이 끝날 때 한 번에 실행하는 방식
  네트워크를 통해 오가는 정보는 유닛의 상태에 관한 정보가 아닌 플레이어가 입력한 명령뿐이므로 RTS게임의 클라이언트는 모든 유닛을 시뮬레이트 해야함
  네트워크로 받은 모든 플레이어의 명령을 한 PC내에서 입력받은 명령처럼 처리하면 모든 플레이어의 명령을 저장해놓고 게임이 끝난 뒤에 다시 똑같은 상황을 재연할 수 있ㅇ므
  결과적으로 락스텝은 모든 클라이언트를 엄격하게 동기화 하므로 특정 클라이언트의 동작이 먼저 끝날 일이 없음
  그러므로 지연이 심한 클라이언트가 있으면 해당 클라이언트가 진도를 따라올 때 까지 모든 클라이언트가 기다려야함
  그런데도 락스텝이 RTS게임에 많이 쓰이는 이유는 네트워크를 통해 전달해야할 데이터의 양이 비교적 적기 때문.
  락스텝은 모든 유닛의 정보가 아닌 명령을 전달하며 아무리 손이 빠른 유저라도 분당 300~400개 이상의 명령을 입력할 수 없으므로 전달할 데이터가 비교적 적음
  P2P모델은 모든 피어가 게임 세계를 시뮬레이트할 수 있으므로 게임의 상태는 100% 결정론적이어야함
  그러므로 운을 바탕으로 하는 게임 플레이는 적용이 어려울 수 있음. 모든 피어를 제대로 동기화하려면 훨씬 많은 노력을 기울여야함
  
부정행위 
  모든 플레이어에게 공정한 게임을 보장해야 한다는 점은 네트워크 게임에서 고려해야할 중요한 문제임
  가능한 한 플레이어의 부정행위를 막을 수 있는 대책을 마련해야함
부정정보획득(information cheat)
  예시)서버가 항상 다른 플레이어의 위치 정보를 보낸다는 점을 이용해 은신 캐릭터의 위치 파악
  부정정보획득을 막는 가장 간단한 방법은 전송하는 정보에 제한을 두는 것
  서버가 은신모드인 캐릭터의 위치 정보를 보내지 않는 방식 등. 해커가 은신캐릭터의 위치를 파악하는 방법을 찾아낸다 해도 은신 모드로 들어가기 전 까지의 위치만 알 수 있을 뿐
  예시)RTS게임의 맵핵
  락스텝모델의 기본적인 동작방식으로 인해 정보를 보내지 않는 방법으로는 맵핵 문제를 해결할 수 없음
  게임을 실행하는 동안 부정행위를 하는 프로그램이 있는지 확인하다가 수상한 프로그램을 실행하는 계정을 감지하면 부정행위자로 기록하는 등의 노력이 필요함
게임 상태 조작 
  플레이어가 게임의 상태를 변경하는 능력을 손에 넣으면 순식간에 일방적인 게임을 만들 수 있음
  특히 호스트가 따로 있는 게임에서 일어나기 쉬움
  예시) 피구게임에서 호스트가 자신을 제외한 모든 클라이언트에게 공에 맞았으니 나가라는 메시지를 전송
  전용 서버를 사용하지 않더라도 해결할 방법은 존재
    부정행위 감지 프로그램을 이용
    클라이언트에 서버의 명령을 검증하는 과정을 추가
중간자공격(man-in-the-middle attack)
  통신 중인 두 기기 사이에 별도의 기기를 배치해서 모든 패킷을 가로채는 부정 행위
  특히 네트워크를 통해 오가는 정보가 플레인 텍스트라면 중간자 공격이 일어나기 쉬움
  HTTP는 모든 데이터를 텍스트로 전달하여 중간에 쉽게 가로챌 수 있지만, HTTPS는 중간에서 정보를 가로채도 가로챈 정보의 판독이 거의 불가능함
  가장 큰 문제점은 게임을 플레이하지 않는 기기에서 부정행위를 저지르므로 감지하기가 어렵다는 것
  해결책 중 하나는 서버에서만 패킷을 복호화해 정보를 확인할 수 있게하고 그 외 모든 패킷은 암호화하는 것
  
연습문제 
  1. 인터넷 프로토콜이란? IPv4와 IPv6의 차이점은?
  2. ICMP란? 게임에서 ICMP를 활용할 수 있는 방법읍?
  3. TCP프로토콜의 중요한 특징
  4. 네트워크에서 포트란?
  5. 실시간 게임에서 UDP프로토콜을 더 많이 사용하는 이유?
  6. 서버/클라이언트 모델이란? 서버/클라이언트 모델과 피어투피어 모델의 차이점은?
  7. 클라이언트 예측에 필요한 요소와 클라이언트 예측을 통해 플레이어의 게임 플레이 경험을 향상할 방법을 설명
  8. 피어투피어 모델 중 RTS에 주로 쓰이는 락스텝 모델에 관해 간단하게 설명
  9. 부정정보획득의 예를 하나 들고 방지하는 방법을 설명
  10. 중간자 공격이란? 중간자 공격을 막는 방법은?  
  
  
