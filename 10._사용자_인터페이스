메뉴 시스템
  잘 만들어진 메뉴시스템이라면 다방면으로 융통성이 있어야함. 메뉴 화면과 메뉴의 수에 제한이 없어야 하며 하위 메뉴를 쉽고 빠르게 추가할 수 있어야함
  동시에 가장 많이 쓰는 기능에 초점을 맞춰서 구현해야함. 이제 탄탄한 메뉴 시스템을 구현하려면 반드시 고려해야할 점에 대해 설명
메뉴스택 
  일반적인 콘솔 게임의 메뉴 시스템은 Press Start 화면에서 시작하고, 시작 버튼을 누르면 메인 메뉴로 넘어감
  플레이어는 메인메뉴에서 설정 메뉴를 불러오거나 크레딧, 게임플레이 방법 등을 살펴볼 수 있음. 대개 플레이어에게 현재 메뉴에서 이전 메뉴로 되돌아가는 수단을 제공하기도 함
  <img src="/01_traditional_menu.jpg">
  항상 기본 메뉴로 돌아올 수 있는 메뉴 흐름을 만드는 방법의 하나는 스택 데이터 구조를 사용한느 것
  스택의 최상위 요소는 현재 표시 중인 메뉴에 해당. 새로운 메뉴 항목으로 넘어갈 때는 새 메뉴를 스택에 넣고(push) 이전 메뉴로 돌아갈 때는 현재 메뉴를 스택에서 꺼냄(pop)
  한발 더 나아가 요청을 수락하거나 거절해야 할 때 메뉴 위에 대화 상자를 표시하는 등 한 번에 여러 개의 메뉴를 표시할 수도 있음.
  이렇게 구현하려면 메뉴를 그릴 때 스택의 맨 아래 메뉴에서 위쪽의 메뉴 순서로 그려야함
  하나의 스택에 모든 메뉴를 저장하려면 모든 메뉴가 상속할 기본 클래스가 필요함.
  기본 클래스에는 메뉴의 이름, 버튼의 연결리스트 또는 메뉴가 지닌 하위 메뉴 등에 관한 정보를 저장할 수 있다. <토니 호크 프로젝트8>의 메뉴 시스템을 만들 때 사용된 방법과 비슷함
  이 메뉴 시스템과 일반적인 스택의 차이점은 스택을 한 번에 싹 비우고 맨 위에 새로운 요소를 넣을 수 있다는 점.
  메인메뉴에서 게임으로 넘어갈 때 메인 메뉴를 띄워놓은 채로 게임을 진행하고 싶지 않다면 이러한 기능이 있어야함
버튼 
  PC, 콘솔 게임의 버튼은 선택하지 않은 상태와 선택한 상태를 시각적으로 다르게 표현해야 플레이어가 자신이 선택한 버튼을 확실히 알 수 있음
  가장 간단한 방법은 버튼의 색을 바꿔주는것이나 텍스처를 바꾸거나 버튼의 크기를 늘리는 방법도 있음
  또한 게임의 메뉴 중에는 해당 메뉴에 대고 버튼을 누르는 중임을 나타내는 세 번째 상태를 사용하는 메뉴도 있지만 꼭 있어야하는 상태는 아님
  터치 기기의 버튼은 대개 선택하지 않은 상태인 기본 상태와 선택한 상태, 두 개의 상태만 지님
  키보드 또는 컨트롤러로만 조작할 수 있는 메뉴라면 버튼을 활용하는 쪽이 간단함
  메뉴 화면 내의 버튼을 이중연결리스트로 연결해두면 사용자가 위, 아래 등의 키를 눌렀을 때 현재 선택중인 버튼의 선택을 취소하고 다음 버튼을 선택하게 만들 수 있음
  또한 이중연결리스트로 연결했으므로 이전 버튼이나 다음 버튼으로 넘어가기도 쉽고 맨처음 버튼을 지나치면 맨 뒤 버튼으로 넘어가거나 맨 뒤 버튼을 지나치면 처음버튼으로 넘어가게도 할 수 있음
  대개 사용자는 버튼을 누르면 당연히 반응이 있을것으로 생각. 적절한 반응을 구현하는 방법의 하나는 반응에 해당하는 함수를 버튼 클래스의 멤버변수로 만드는 것
  구현 방법은 언어에 따라 다르지만 C#은 액션, C는 함수포인터, C++은 람다표현식으로 구현할 수 있음
  이렇게 하면 버튼을 새로 만들 때 적절한 함수와 연결해놓고 버튼이 눌릴 때 해당 함수를 실행할 수 있음
  마우스로도 메뉴를 다룰 수 있는 게임이라면 메뉴 시스템이 모든 버튼에 마우스로 해당 버튼을 선택할 수 있는 영역을 나타내는 2D 경계상자 '핫존'을 설정하는 조금 복잡한 처리를 추가해야함
  그리고 마우스를 메뉴 근처로 움직이면 마우스의 새로운 위치가 버튼의 핫존과 교차하는지 확인해야함
  사용자가 마우스와 키보드를 오가며 메뉴를 다루게도할 수 있음. 널리 쓰이는 방법의 하나는 사용자가 키보드의 버튼을 누르면 마우스 커서를 감추면서 마우스 위치를 무시하고
  다시 마우스를 움직이기 시작하면 마우스 선택 기능을 되돌리는 것
  키보드와 마우스, 컨트롤러를 모두 지원하는 게임이라면 메뉴시스템이 해야할 일이 매우 많아짐
타자입력 
  컴퓨터 게임은 메뉴 안에서 플레이어에게 하나 이상의 단어를 입력받아야 할 때가 있음
  예시)고득점자 목록에 올릴 이름이나 세이브, 로드에 사용할 파일 이름 등은 플레이어의 타자로 입력받을 수 있음
  전통적으로 타자 입력을 지원하는 프로그램은 대개 표준입력을 통해 해결했으나 게임은 대부분 표준입력을 사용하지 않음
  타자 입력을 받으려면 먼저 빈 문자열을 마련해놓고 플레이어가 문자를 입력할 때마다 해당 문자를 문자열에 추가해야하는데 이렇게 하려면 플레이어가 타자한 문자를 정확히 파악해야함
  키보드상의 모든 키를 열겨형 인덱스에 매핑했던 가상 키 코드를 떠올려볼 것.(K_A = 'A', K_SPACE = ' '...)
  아스키 코드에서 문자 'B'는 문자 'A'의 다음인데 똑같이 증가한다는 점을 활용하여 문자 키코드를 해당 문자로 변환하는 함수로 구현할 수 있음
function KeyCodeToChar(int keyCode) 
  //문자 키인지 확인
  if keyCode >= K_A && keyCode <== K_Z
    //일단 대문자로 가정, 언어에 따라 char로 형변환을 해야할 수도 있음
    return ('A' + (char)(keycode - K_A))
  else if keyCode == K_SPACE
    return ' '
  else
    return ' '
  end
end
  필요에 따라 대소문자를 구분하게 수정할 수도 있음(쉬프트키와 눌린 키는 대문자로 처리)
  
HUD의 구성 요소(Head Up Display)
  가장 기본적인 헤드업 디스플레이는 플레이어의 점수와 남아있는 생명의 수 등 요소를 보여주는 형태
  이런 형태의 HUD는 구현하기 쉬움. 게임 세계를 그리고 나서 그 위에 표시할 정보가 담긴 텍스트나 아이콘만 그려주면 됨
  하지만 방향을 나타내는 화살표, 레이터, 나침반, 조준선 등 더욱 복잡한 요소를 사용하는 게임도 있음
방향지시 화살표(waypoint arrow)
  플레이어의 다음 목적지를 알려주는 역할을 함. 가장 간단한 구현 방법의 하나는 화면에 3D오브젝트를 배치해놓고 플레이어가 근처에 오면 화살표를 회전시켜 플레이어가 가야할 방향을 가르키는 것
  이를 구현하려면 먼저 회전하지 않은 상태에서 정면을 가리키는 화살표 모델을 만들어야함. 그 다음 게임플레이 상황에 따라 적용할 파라미터 세 개를 만듬
    각각 화살표의 방향을나타내는 벡터, 화면공간상에서 화살표의 위치, 화살표가 가리켜야하는 목적지의 위치
    화살표의 방향 벡터
      화면의 안쪽으로 들어가는 축의 방향으로 초기화해야 함. 전통적인 왼손좌표계에서는 z축에 해당
    화면공간상에서 화살표의 위치
      (x, y)좌표이므로 3D인 화살표를 정확한 위치에 그리려면 3D월드공간좌표로 변환해야함
      픽킹과 마찬가지로 언프로젝션이 필요
    목적지의 위치
      화살표가 가리킬 목적지의 위치
  방향지시 화살표를 업데이트하려면 프레임마다 화살표가 가리켜야 할 방향을 나타내는 벡터를 구해야함
  이 벡터는 플레이어의 위치에서 목적지의 위치로 향하는 벡터를 만든 뒤에 정규화하면 구할 수 있음
  그 다음 내적과 외적을 사용해서 화살표의 원래 방향이었던 화면의 안쪽으로 들어가는 벡터와 새로운 방향을 나타내는 벡터 사이의 회전 각도 및 회전축을 알아야함
  여기까지 마쳤다면 사원수를 사용해서 회전을 수행할 수 있음. 화살표를 좀 더 매끄럽게 회전시키고 싶다면 선형 보간을 사용
  <img src="/02_waypoint_arrow.jpg">
  밑의 코드는 지금까지 설명한 방식으로 방향지시 화살표를 구현한 코드. 주의할 점이 몇개 있음
    우선 방향지시 화살표를 업데이트하기 전에 카메라를 업데이트 해야함
    그래야만 방향지시 화살표를 항상 화면상의 똑같은 위치에 표시할 수 있으며 그렇지 않으면 카메라가 움직일 때마다 방향지시 화살표가 한프레임씩 늦게 반응하여 이리저리 흔들림
  방향지시 화살표는 게임 세계의 모든 3D오브젝트를 그린 뒤에 Z버퍼를 끈 상태에서 그려야함
    이렇게 하면 3D공간상에서 화살표와 카메라 사이를 가로막는 3D오브젝트가 있더라도 화살표가 맨 앞에 그려짐
방향지시 화살표 
class WayPointArrow 
  //화살표의 현재 방향을 저장
  Vector3 facing
  //화살표를 표시할 화면상의 위치(2D)
  Vector2 screenPosition
  //화살표가 가리킬 목적지
  Vector3 waypoint
  //화살표를 그릴 때 사용할 월드변환행렬
  Matrix worldTransform
  
  //주어진 위치, 회전을 바탕으로 월드 변환 행렬을 계산하는 함수
  function ComputeMatrix(Vector3 worldPosition, Quternion rotation)
    //신축,회전,이동을 적용(해당 예제에서 신축은 생략)
    worldTransform = CreateFromQuternion(rotation) * CreateTranslation(worldPosition)
  end
  
  //screenPosition을 바탕으로 3D화살표의 월드 공간 위치를 구함
  function ComputeWorldPosition()
    //언프로젝션을 수행하려면 3D벡터가 필요
    //z 성분은 가까운 평면과 먼 평면 사이의 위치를 백분율로 나타낸 값, 예제에서는 10%인 지점 즉 z=0.1
    Vector3 unprojectPos = Vector3(screenPosition.x, screenPosition.y, 0.1)
    
    //카메라행렬과 프로젝션 행렬을 구함
    ...
    
    //8장에서 만든 Unproject 함수 호출
    return Unproject(unprojectPos, cameraMatrix, projectionMatrix)
  end
  
  function Initialize(Vector2 myScreenPos, Vector3 myWaypoint)
    screenPosition = myScreenPos
    //왼손 좌표계에서는 Y축이 위쪽
    facing = Vector3(0, 0, 1)
    SetNewWaypoint(myWaypoint)
    
    //월드변환 행렬을 초기화
    ComptuteMatrix(ComputeWorldPosition(), Quternion.Identity)
  end
  
  function SetNewWayPoint(Vector3 myWaypoint)
    waypoint = myWaypoint
  end
  
  function Update(float deltaTime)
    //화살표의 월드 공간위치를 구함
    Vector3 worldPos = ComputeWorldPosition()
    
    //플레이어의 위치를 구함
    ...
    //화살표의 새로운 방향벡터는 플레이어의 위치에서 목적지를 향하는 벡터를 정규화한 벡터
    facing = waypoint - playerPosition
    facing.Normalize()
    
    //내적을 사용해서 원래 방향 벡터인(0, 0, 1)과 새로운 방향벡터 사이의 각도를 구함
    float angle = acos(DotProduct(Vector3(0, 0, 1), facing))
    //외적을 사용해서 회전축을 구함
    Vector3 axis = CrossProduct(Vector3(0, 0, 1), facing)
    Quternion quat
    //외적의 크기가 0이면 두 벡터는 평행, 회전이 일어나지 않았다는 의미
    if axis.Length() < 0.01f
      quat = Quaternion.Identity
    else
      //회전을 나타내는 사원수를 구함
      axis.Normalize()
      quat = CreateFromAxisAngle(axis, angle)
    end
    
    //이제 방향지시 화살표에 최종 월드변환행렬을 적용
    ComputeMatrix(worldPos, quat)
  end
end  

조준선
  일인칭, 삼인칭 총격전 게임에 쓰이는 HUD요소. 이를 이용해 자신이 조준하고있는 위치뿐만 아니라 조준하고있는 대상이 적인지 아군인지 등의 부가적인 정보를 얻을 수 있음
  조준선의 모양에 관계없이 구현 방법은 거의 같음. 8장에서 설명한 마우스 피킹과 매우 유사
  마우스 커서와 마찬가지로 조준선도 2D화면상에 그려짐. 이 2D위치에서 한 번은 가까운 평면에, 한 번은 먼 평면에 총 두 번의 언프로젝션을 수행해야함
  언프로젝션의 결과로 가까운 평면상의 위치와 면 평면상의 위치를 얻고 나면 두 위치를 대상으로 레이캐스트를 수행하고 물리계산을 통해 레이캐스트에 걸리는 모든 오브젝트의 리스트를 만듬
  이렇게 만든 리스트에서 레이캐스트에 맨 처음 걸린 오브젝트를 선택. 간단한 게임이라면 레이캐스트에 맨 처음 걸린 오브젝트가 가까운 평면상의 위치에서 가장 가까운 오브젝트일 확률이 큼
  하지만 오브젝트의 크기가 크면 그렇지 않을 수도 있음. 따라서 복잡한 게임이라면 선분과 각 오브젝트가 실제로 교차하는 위치를 비교해야 할 수도 있음
  조준선의 선분과 교차한 오브젝트를 찾고나면 해당 오브젝트가 적인지 아군인지, 아니면 공격 대상으로 삼을 수 없는 오브젝트인지 확인할 수 있으며
  확인 결과에 따라 조준선의 색을 변경
레이더 
  플레이어를 중심으로 일정한 반경 안에 있는 적, 아군을 보여주는 레이더가 있는 게임도 존재
  레이더의 표시 방식은 두어가지 정도로 나뉘는데 하나는 반경 안의 적과 아군을 모두, 다른 하나는 최근에 무기를 발사한 적만 보여주는 방식
  방식에 관계없어 구현방법은 거의 똑같음
  레이더를 제대로 구현하려면 두 가지를 해결해야함
    레이더에 표시할 수 있는 모든 오브젝트가 레이더의 범위 안에 속하는지 반복해서 확인할 방법이 필요
    그런 다음 레이더 범위 안에 있는 모든 오브젝트와 레이더의 중심 간의 거리를 구해서 2D로 변환한 뒤 UI에 오브젝트를 표시
      거리를 구한 후 2D로 변환할 때 높이는 모두 무시
  계산 방법을 살펴보기 전 레이더 블립(blip)으로 사용할 구조체를 선언해야함. 이 구조체를 사용하면 타겟에 따라 블립의 크기와 색상을 다양하게 변경할 수 있음
    레이더 블립 : 레이더 UI에서 오브젝트를 나타내는 작은 점을 의미
struct RadarBlip
  //레이더 블립의 색상
  Color color = Color.Red
  //레이더 블립의 2D 위치
  Vector2 position
  //레이더 블립의 크기
  float scale = 1.0f
end  
  원한다면 RadarBlip을 바탕으로 다양한 적을 각각 다른 형태로 표시하는 블립을 만들 수도 있음
  실제로 레이더 클래스에서 중요한 파라미터는 레이더가 게임 세계의 오브젝트를 감지할 수 있는 최대 거리와 화면에 표시할 레이더의 반지름임
  두 개의 파라미터만 있으면 블립의 위치를 화면 위에 표시할 정확한 위치로 변환할 수 있음
  예시)50단위 거리까지 감지할 수 있는 레이더를 사용하는 게임에서 플레이어의 정면으로 25단위 떨어진 위치에 오브젝트를 레이더에 표시하고싶다고 할 때,
    오브젝트의 위치는 3D이므로 레이더에 표시하려면 플레이어와 오브젝트의 위치를 모두 2D좌표로 변환해야함. y축이 위쪽을 가리키는 경우 이는 xz평면임
    예제코드에서는 2D위치의 두 번째 성분을 계속 y라고 하지만 실제로는 3D좌표(x,y,z)를 2D좌표(x,z)에 매핑한다는 의미
    플레이어의 위치와 오브젝트의 위치를 레이더의 평면에 투영한 2D좌표로 변환하고 나면 플레이어에서 오브젝트로 향하는 벡터를 만들 수 있음. 이를 a->라고 가정
    a->의 길이를 계산하면 오브젝트가 레이더의 범위 안에 있는지 알 수 있지만 처리해야 할 문제가 하나 더 있는데, 대부분 게임의 레이더는 플레이어가 회전할 때 같이 회전함
    즉 레이더의 위쪽은 항상 플레이어가 향하는 방향과 일치해야하는데 이런 관계를 고려해서 플레이어의 방향벡터에 따라 a->를 회전해야함
    <img src="/03_radar_up.jpg">
    이 문제를 해결하려면 플레이어의 방향 벡터도 정규화해서 레이더의 평면에 투영한 다음 투영한 벡터와 대개 <0,1>인 화면상 레이더의 앞쪽을 가리키는 벡터의 내적을 구하면 회전각도를 구할 수 있음
    두 벡터를 z성분이 0인 3D벡터로 변환한 뒤에 외적을 수행하면 회전해야할 방향(시계, 반시계)도 알 수 있음, 두 2D벡터를 외적한 결과의 z성분이 양수면 회전방향이 반시계임
    회전할 각도와 방향을 구하고 나면 2D회전행렬을 사용해서 a->를 올바른 방향으로 회전시킬 수 있음
    2D 회전행렬은 항상 z축을 기준으로 하므로 일차변환일 수 밖에 없는데 행우선으로 표현한 벡터의 2D회전행렬은 다음과 같음
    <img src="/04_2D_rotation_matrix.jpg">
    이때 쎄타는 회전의 방향에 따라 양수 또는 음수로 바뀜. 외적의 결과를 바탕으로 반시계방향이면 양수, 시계방향이면 음수를 대입해야함
    a->가 플레이어의 위치를 시작으로 플레이어의 정면으로 25단위만큼 떨어진 위치를 가리키는 벡터라면 회전을 적용한 결과는 a-> = <0, 25>임
    이제 이 2D벡터의 각 성분을 레이더의 최대 감지 거리로 나누면 원형 레이더상에 블립을 놓아야 할 위치를 나타내는 벡터를 얻을 수 있음. 즉 <0, 25> / 50 = <0, 0.5>
    그런 다음 화면에 표시할 레이더의 반지름과 2D벡터의 각 성분을 곱함. 200픽셀의 반지름으로 레이더를 표시한다면 레이더의 중심에서 떨어진 거리 즉 블립을 표시하하는 2D벡터는 <0, 100>
    <img src="/05_radar_result.jpg">
레이더시스템 
class Radar
  //게임세계의 거리 단위로 나타낸 레이더의 감지 범위
  float range
  //화면에 표시할 레이더 중심의 위치(x,y)
  Vector2 position
  //화면에 표시할 레이더의 반지름
  float radius
  //이 레이더의 배경 이미지
  ImageFile radarImage
  //RadarBlip의 리스트
  List blips
  
  //레이더의 범위, 중심, 반지름, 이미지를 설정하는 초기화 함수
  ...
  
  function Update(float deltaTime)
    //이전 프레임에서 사용했던 블립 리스트를 비움
    blips.Clear()
    //플레이어의 위치를 구함
    ...
    //플레이어의 위치를 2D좌표로 변환, 아래 코드는 y축이 위쪽을 가리키는 게임세계라 가정
    Vector2 playerPos2D = Vector2(playerPosition.x, playerPosition.z)
    
    //블립에 적용할 회전을 계산
    //먼저 플레이어의 방향벡터를 정규화
    ...
    //플레이어의 방향벡터를 2D로 변환
    Vector2 playerFacing2D = Vector2(PlayerFacing.x, playerFacing.z)
    //2D로 변환한 플레이어의 방향벡터와 레이더의 '정면'을 가리키는 벡터사이의 각도를 구함
    float angle = acos(DotProduct(playerFacing2D, Vector2(0,1)))
    //외적을 수행할 수 있게 플레이어의 방향벡터를 3D로 변환
    Vector3 playerFacing3D = Vector3(playerFacing2D.x, playerFacing2D.y, 0)
    //외적을 통해 회전방향을 알아냄
    Vector3 crossResult = CrossProduct(playerFacing3D, Vector3(0, 1, 0))
    //시계방향 회전이면 z가 홀수. 즉 각도를 음수로 바꿔줘야함
    if crossResult.z < 0
      angle *= -1
    end
    
    //레이더 범위 안에 있는 적을 찾음
    foreach Enemy e in gameWorld
      //적의 위치를 2D 좌표로 변환
      Vector2 enemyPos2D = Vector2(e.position.x, e.position.z)
      //플레이어에서 적으로 향하는 벡터인 playerToEnemy를 만듬
      Vector2 playerToEnemy = enemyPos2D - playerPos2D
      //벡터의 길이로 레이더의 범위 안쪽인지 확인
      if playerToEnemy.Length() <= range
        //2D 회전행렬을 사용해서 playerToEnemy가 플레이어와 같은 방향을 향하게 회전
        playerToEnemy = Rotate2D(playerToEnemy, angle)
        //이 적을 표시할 때 사용할 레이더 블립을 만듬
        RadarBlip blip
        //playerToEnemy벡터를 화면에 표시한 레이더의 중심으로부터 떨어진 거리로 변환해서 블립의 위치를 구함
        blip.position = playerToEnemy
        blip.position /= range
        blip.position *= radius
        //블립 리스트에 방금 만든 블립을 추가
        blips.Add(blip)
      end
    loop
  end
  
  function Draw(float deltaTime)
    //레이더의 배경인 radarImage를 그림
    ...
    
    foreach RadarBlip r in blips
      //블립에 들어있는 blip.position은 레이더 중심에서 떨어진 거리이므로 position + blip.position에 블립 r을 그림
      ...
    loop
  end
end
  이 레이더는 다양한 방식으로 개선할 수 있음. 색깔 수정으로 적과 아군을 모두 확인하거나, 높이의 개념을 추가하거나
  <콜오브듀티>처럼 최근에 무기를 발사한 적만 표시하는 방법도 있음. 이렇게 하려면 적이 무기를 발사할 때마다 레이더에 표시하라는 의미를 지니는 플래그 값을 임시로 설정하고
  게임 루프 내에서 블립으로 표시할 적을 확인할 때 플래그 값도 확인해야함

기타 UI 고려사항 
다양한 해상도 지원
  UI가 활용할 수 있는 픽셀의 수가 모니터에 따라 달라질 수 있음
  다양한 해상도 지원은 PC게임만의 문제가 아닌 콘솔게임에도 존재하는 문제임
  다양한 해상도를 지원하는 방법의 하나는 직접 픽셀 위치를 지정하는 절대 좌표를 사용하지 않는 것
  이런 문제를 해결하려면 다른 좌표와의 관계를 나타내는 상대좌표를 사용해야함
  예시)화면의 오른쪽 아래 구석에 UI요소를 그리고싶다면 화면의 오른쪽 아래 모서리를 기준으로 (-100, -100)떨어진 위치에 그리는 것
  상대 좌표는 화면의 한 구석이나 중앙 등 화면 상의 주요 지점을 기준으로 배치하거나 다른 UI요소를 기준으로 배치할 수 있으나 구현이 복잡함
  또한 해상도에 따라 UI요소를 확대, 축소하는 방식으로 개선해야할 수도 있음
    고해상도일 때는 플레이어의 눈에 잘보이게 UI를 확대, 플레이어가 직접 UI를 확대,축소할 수 있는 슬라이더를 가진 게임도 존재
    이를 지원하려면 상대좌표 활용의 중요성이 더욱 커짐
현지화(Localization) 
  대부분의 상용게임은 두 개 이상의 언어를 지원. 현지화는 지원할 언어를 추가하는 과정을 의미함
  메뉴와 HUD에는 텍스트가 많이 들어가므로 UI시스템을 설계할 때 미리 현지화를 고려해야함.
  현지화할 필요가 없는 게임이라도 화면에 표시할 텍스트를 소스 파일에 하드코딩하는 방법은 프로그래머가 아니면 텍스트 수정이 힘드므로 바람직하지 않음
  가장 간단한 방법은 게임에서 사용하는 모든 텍스트를 별도의 XML, JSON파일 등으로 저장하는 것
  이렇게 만든 파일은 문자열과 문자열을 나타내는 키로 이뤄진 간단한 딕셔너리에 매핑할 수 있음
  따라서 화면에 텍스트를 표시해야 하는 코드는 적절한 키를 사용해서 딕셔너리에 텍스트를 요청해야함
  예시)버튼에 표시할 문자열 "cancel"을 하드코딩하지 않고 "ui.cancel"이라는 키에 해당하는 문자열을 딕셔너리에 요청해야함
  이때 똑같은 딕셔너리 형태의 파일을 새로 만들고 안에 들어갈 텍스트를 원하는 언어로 바꿔주기만 하면 지원하는 언어를 하나 더 늘릴 수 있음
  하지만 다른 문자집합을 사용하는 언어를 지원하려면 문제가 복잡해질 수 있는데, 대부분의 언어에서 char형식으로 쓰이는 전통적인 아스키 문자집합은 영문알파벳만을 지원하기 때문
  다양한 문자 체계를 지원해야하는 게임이라면 유니코드 문자집합을 사용해야함. 유니코드 문자를 인코딩하는 방법은 다양하나 가장 널리 쓰이는 방식은 가변길이 인코딩 UTF-8
  UTF-8에서 표준 아스키 문자는 1바이트지만 유니코드 문자는 2~6바이트일 수 있음. 이렇게 인코딩할 언어에 따라 길이가 달라질 수 있으므로 메모리에 들어있는 문자열을 인코딩했을 때 크기추측이 가능
  하지만 문자열과 문자의 인코딩방식이 바뀐다는 점 외에도 생각해야할 것이 많음. 단어 자체가 원래 긴언어가 있다는 점도 고려해야함
  예시)독일어 단어는 평균적으로 영어단어보다 더 김(약 20~25%)
  즉 영어일 때 UI에 들어갈 텍스트의 길이가 딱 맞아도 다른 언어일 때 딱 맞을 확률이 거의 없음
  또한 현지화할 국가에 따라 텍스트와 음성의 현지화는 물론이고 해당국가의 법률등에 따라 내용 자체를 현지화해서 해야 할 수도 있음
  예시)독일은 나치와 관련있는 상징사용을 금지, 폭력에 관해 엄한 잣대를 가진 국가라면 혈흔, 폭력적인 장면을 없애야함
  이는 현지화 문제가 단순히 UI문제만은 아님을 의미함
UI미들웨어 
  게임용 UI, 특히 AAA게임용 UI얘기를 하려면 대세인 오토데스크의 스케일폼(Scaleform)이라는 미들웨어를 빼놓을 수 없음 하지만 이는 무료가 아님
사용자경험(UX) 
  UI의 매우 중요한 측면
  예시) 간단한 동작을 할 때도 버튼을 몇 번씩 눌러야 한다는 느낌이 든다면 잘못 설계한 UI
 
연습문제
  1.  메뉴스택을 사용할 때의 장점
  2. 문자 키코드를 문자로 변환하는 함수를 구현할 때 고려할 수 있는 문자 키코드의 특징
  3. 방향지시 화살표를 구현할 때 3D화살표를 배치할 월드 공간상의 위치를 구하는 방법
  4. 방향지시 화살표의 회전축과 회전 각도를 계산하는 방법 설명
  5. 조준선으로 조준하고 있는 타겟이 적인지 아군인지 확인하는 방법을 설명
  6. 레이더를 구현할 때 오브젝트의 3D좌표를 2D인 레이더에 표시할 2D좌표로 변환하는 방법을 설명
  7. 절대 좌표와 상대 좌표의 차이점
  8. UI에 표시할 텍스트를 하드코딩하지 말아야 하는 이유
  9. 유니코드 문자 집합을 사용해서 해결할 수 있는 문제점은?
  10. 사용자 경험 UX란?
