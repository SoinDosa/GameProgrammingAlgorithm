스크립트언어
  한동안 게임은 기기성능의 최적화를 위해 어셈블리 언어를 사용해옴. 하지만 컴퓨터의 성능이 높아지고 게임이 복잡해지면서 어셈블리로 개발하여 얻는 장점이 완전히 사라짐
  이런 이유로 최신 게임엔진은 모두 C++과같은 고급언어로 만들어짐
  요즈음 게임 플레이에 관한 코드의 많은 부분을 루아, 파이썬, 언리얼스크립트 등 상위 레벨 언어인 스크립트 언어로 작성하는 게임도 많음
  스크립트 코드는 작성하기 쉬우므로 디자이너가 직접 작성할 수 있을때도 있음. 즉 엔진코드를 잘 모르는 디자이너라도 자신의 아이디어를 프로토타이핑할 수 있다는 의미
  AAA게임의 물리 시스템이나 렌더링 시스템처럼 게임 엔진의 언어로 작성할 수밖에 없는 부분도 여전히 남아있긴 하지만 카메라, AI행동 등은 스크립트로도 작성할 수 있음
스크립트언어의 장단점
  스크립트 언어의 성능은 C++과 같은 컴파일 언어의 성능에 미치지 못함
    예시)루아, 파이썬같은 인터프리터 스크립트 언어는 자바나 C#처럼 JIT, 가상마선을 사용하는 언어와 비교해도 성능 면에서 경쟁력이 없음
    인터프리터 언어는 텍스트로 작성한 코드를 미리 컴파일하지 않고 필요할 때 읽어와서 실행하는 방식이기 때문
  코드를 중간상(intermediary)으로 컴파일할 수 있는 스크립트 언어도 존재, 이는 순수 컴파일언어만큼 빠르지는 않지만 대개 인터프리터 언어보다는 빠름
  하지만 여전히 성능의 차이가 있으므로 높은 성능을 요구하는 코드는 스크립트로 구현해선 안됨
  AI중에서도 A*길찾기 알고리즘은 높은 성능을 요구하므로 스크립트로 작성하면 안되지만 AI의 행동을 좌우하는 상태머신은 복잡한 계산이 필요없으므로 스크립트 언어로 작성할 수 있음
  예제 게임에서 스크립트 언어의 용도)
    C++ : 렌더링 엔진, AI(길 찾기), 물리 시스템, 파일로드
    스크립트언어 : 카메라로직, AI(상태 머신), 일반적인 게임 플레이 로직, 사용자 인터페이스
  스크립트 언어의 가장 큰 장점은 각 개발 단계를 빠르게 반복할 수 있다는 점
  예시)AI상태머신을 C++로 작성한 게임을 테ㅐ스트하던 프로그래머가 이상하게 행동하는 적을 발견했다고 가정
    C++코드라면 다양한 툴을 사용해서 문제를 분석해낼 수 있지만 프로그램을 실행 중인 상태에서는 문제를 수정할 수 없음
    대개 프로그래머는 게임을 중단하고 소스 수정->실행파일 빌드->게임다시시작 과정을 거쳐야 문제를 제대로 해결했는지 알 수 있음
    하지만 스크립트 언어로 AI상태머신을 작성했을 경우 똑같은 상황이 벌어지면 게임이 실행 중인 상태더라도 동적으로 AI스크립트를 다시 로드하여 수정한 내용을 반영할 수 있음
    이는 생산성을 매우 높여줌
    또한 C++로 AI행동을 구현한 코드에서 AI코드에 가끔 알 수 없는 포인터에 접근하는 버그가 있다고 가정. 이 버그를 해결하지 못하면 게임이 시스템과 충돌하는 일이 벌어짐
    하지만 상태 머신을 스크립트로 작성했다면 AI르 적용한 캐릭터의 기능이 멎어도 게임의 실행에 영향을 주지 않음
  스크립트는 실행 파일과 상관없는 별도의 파일이므로 내용을 수정한 뒤, 쉽게 배포할 수 있음. 규모가 큰 프로젝트의 실행 파일은 빌드만 몇 분씩 걸릴 수 있고 파일 크기가 100MB에 육박할 수 있음
  또한 새 버전이 나올 때마다 업데이트를 원하는 사용자는 거대한 실행 파일을 통째로 다운로드해야하지만, 스크립트 언어를 사용하면 몇 KB정도의 데이터만 다운로드하면 끝이므로 업데이트 시간이 단축됨
  이렇게 생산성 측면에서 큰 장점이 있으므로 성능에 민감한 부분이 아니라면 스크립트로 작성하는 쪽이 나을 수 있음
  게임에 스크립트 시스템을 추가하는 일 자체가 부담이긴 하지만 개발팀에 속한 모든 개발자의 생산성을 높일 수 있다면 그 정도 노력은 가치가 있음
스크립트 언어의 종류 
  스크립트 언어를 사용하기로 했다면 루아, 파이썬과 같은 기존 스크립트 언어를 사용할지, 아니면 게임엔진의 전용 스크립트 언어를 사용할 지 생각해야함
  예시)언리얼스크립트, 퀘이크C(QuakeC)
  기존 언어를 사용할 때의 장점은 할 일이 훨씬 줄어듬
  스크립트 파서 구현은 시간도 많이 들고 오류가 발생하기 쉬운 복잡한 작업이므로 상대적으로 부실한 전용언어의 파서를 쓰다보면 직접 구현해야 할 기능이 늘어남
  게다가 전용 언어는 기존 언어보다 사용자의 수가 훨씬 적으므로 언어 자체의 오류가 고쳐지지 않고 오랫동안 남아있을  가능성이 큼(예시:연산자 우선순위의 오류)
  그 밖에도 기존 언어는 대개 언어에 관해 대부분의 게임프로그래머보다 많이 알고 있으며 컴파일러와 가상 머신을 훤히 꿰고 있는 개발자가 설계하고 구현한 언어라는 점을 고려해야함
  하지만 기존 스크립트 언어는 게임 어플리케이션에 적합하지 않을 수도 있다는 문제가 존재
  언어의 설계 방식에 따라 성능 문제나 메모리 할당 문제가 있을 수 있고 스크립트 언어와 게임 엔진을 통합하기 어려울 수도 있음
  전용 언어는 게임개발에 중점을 두고 만들어진 언어임
  마지막으로 고려할 점은 기존 스크립트 언에에 능숙한 개발자를 찾기가 쉽다는 것, 이미 루아나 파이썬같은 언어를 잘 알고 있는 프로그래머는 매우 많음
  하지만 특정 회사나 게임 엔진에서만 쓰는 전용 언어를 잘 아는 개발자는 찾기 어려움
루아(Lua)
  요즘 게임에 가장 널리 쓰이는 범용 스크립트 언어, <WOW>, <컴퍼티오브히어로즈>, <그림 판당고> 등에서 사용
  루아가 게임 개발에 많이 쓰이는 이유는 인터프리터가 매우 가볍기 때문. C로 만들어진 루아의 인터프리터는 150KB의 메모리를 차지함
  루아의 함수 호출로 C, C++코드를 실행할 수 있는 네이티브 바인딩이 간단함. 또한 멀티태스킹을 지원하므로 여러 개의 루아 함수를 동시에 실행할 수도 있음
  루아의 문법은 C계열 언어와 비슷한 점도 있고 다른 점도 있음
  행의 끝에 세미콜론을 쓰든 말든 상관하지 않으며 제어문에 괄호를 사용하지 않으며 루아가 지원하는 복합 데이터 형식은 '테이블'하나 뿐임
  테이블은 다음 코드처럼 배열, 리스트, 집합 등 다양한 방식으로 활용할 수 있음
--주석-- 
-- 배열로 만든다, 배열의 인덱스는 1에서 시작
t = { 1, 2, 3, 4, 5 }
-- 4 출력
print(t[4])

-- 딕셔너리로 만듬
t = { M = "Monday", T = "Tuesday", W = "Wednesday" }
-- Tuesday 출력
print(t[T])

  루아는 객체지향 언어가 아니지만 테이블을 잘 활용하면 OOP를 완벽하게 구현할 수 있음. 이는 게임에 OOP를 적용해야할 일이 생기면 유용하게 사용

언리얼스크립트
  에픽의 언리얼 엔진용으로 설계한 엄격한 객체지향 언어. 다른 스크립트 언어와 달리 얼리얼 스크립트는 컴파일이 필요함
  그러므로 성능이 인터프리터 언어보다 뛰어나지만 실행 중에 스크립트를 다시 로드할 수 없음
  언리얼을 사용하는 게임은 보통 게임 플레이에 관한 모든 코드를 언리얼스크립트로 만듬 무료 UDK만 사용하는 게임이 아닌 언리얼엔진을 통째로 사용하는 게임이라면
  네이티브 바인딩을 통해 언리얼 함수를 C++로 구현할 수 있음
  <img src="/01_unreal_script_native_binding.jpg">
  언리얼스크립트의 문법은 C++, 자바와 매우 비슷함. 모든 클래스는 어떤 식으로든 Object를 상송하며 화면상의 캐린터를 나타내는 클래스는 거의 모두 Actor를 상속
  매우 독특한 특징은 기본적으로 상태를 지원한다는 것. 상태에 따라 함수를 다양하게 정의할 수 있음
  예시) AI행동에 사용할 상태 머신을 아주 쉽게 만들 수 있음
  다음 코드를 보면 클래스의 현재 상태에 따라 다른 Tick함수를 호출. Tick은 언리얼스크립트에서 오브젝트를 업데이트하는 함수
//auto는 이 상태가 기본 상태라는 뜻
auto state Idle {
  fucntion Tick(float DeltaTime) {
    // '대기' 상태에서의 업데이트
    ...
    
    //적을 발견하면 '경계'상태로 넘어감
    GoToState('Alert')
  }
Begin:
  `log("Entering Idle State")
}
state Alert {
  function Tick(float DeltaTime) {
    //'경계'상태에서의 업데이트
    ...
  }
Begin:
  `log("Entering Alert State")
}

비주얼 스크립팅 시스템(visual scripting system)
  요즘은 흐름도에서 보이는 비주얼 스크립트 시스템을 제공하는 게임엔진이 많아짐. 이는 주로 레벨 로직을 만들 때 사용
  비주얼 스크립팅 시스템을 사용하면 플레이어가 문을 여자 마자 적이 등장하게 하는 등의 동작을 코드가 아닌 흐름도를 통해 간단하게 설명할 수 있음
  <img src="/02_visual_scripting_system.jpg">
  
스크립트 언어의 구현 
  스크립트 언어의 구현 방법을 전부 설명하면 책의 범위를 넘어서나 적어도 구현에 꼭 필요한 요소 정도는 살펴볼 필요가 있음
  스크립트 언어를 사용할 때 발생하는 문제의 복잡함을 알려주고 올바른 해법을 찾는데 도움이 될 것임
  전용 스크립트 언어를 구현하는 방법은 기본적으로 범용 컴파일러를 만드는 방법과 매우 비슷함. 컴파일러관련 서적을 참고할 필요가 있음
  컴파일러를 직접 구현할 일이 없더라도 프로그래밍의 수준을 한 단계 높이려면 컴파일러의 기본적인 동작 방식을 잘 알아야함
  컴파일러 이론이 없었다면 아직도 코드를 어셈블리로 작성해야했을수도 있음
토큰화(tokenization)
  언어를 읽어들이려면 텍스트로 이뤄진 코드를 식별자, 키워드, 연산자, 기호와 같은 토큰으로 분해해야함
  좀더 고급진 단어로 어휘분석(texical analysis)
  <img src="/03_tokenization.jpg">
  스캐너, 렉서라고도 하는 어휘 분석기를 직접 작성할 수도 있지만 권장할 만한 작업은 아님. 직접어휘 분석기를 작성하려면 처리해야할 상황이 너무 많으므로 오류가 발생하기 쉬움
  예를 들어 C++어휘 분석기는 다음 키워드 중 단 하나만 실제 new 키워드로 인식할 수 있어야함
  newnew, _new, new_new, _new_, new 등...
  어휘 분석기를 직접 만들지 말고 어휘 분석기를 만들어주는 플렉스같은 툴을 사용하는 쪽이 나음
  플렉스에게 정규표현식이라는 일련의 매칭 규칙을 전달하면 자동으로 규칙에 맞는 토큰을 뽑아내는 어휘 분석기 코드를 만들어줌
정규표현식(regular expression)
  regex라고도 하는 정규표현식은 토큰화 외에도 용도가 다양함. 대부분의 IDE는 검색을 수행할 때 정규표현식을 사용함
  정규표현식을 사용하면 여러 파일에 들어있는 키워드같은 연속적인 문자나 숫자 형태를 쉽게 찾을 수 있음.
  일반적인 정규표현식은 상당히 복잡하지만 스크립트 언어의 구현에 필요한 패턴 매칭 정도는 정규표현식의 극히 일부만 활용해도 충분
  가장 기본적인 정규표현식은 항상 모든 문자가 같은 순서로 이어져야 하는 키워드와 일치하는 형태
  키워드와 일치하는 정규표현식은 다음과 같이 따옴표와 관계없이 연속으로 이어진 문자로 이루어짐
//new 키워드와 일치
new
//역시 new 키워드와 일치
"new"
  정규표현식에서 특별한 의미를 지니는 연산자도 존재하는데 []연산자는 대괄호 안의 문자 중 하나와 일치해야 한다는 의미
  또한 다음과 같이 하이픈과 조합해서 문자의 범위를 지정하기도 함
//aac, abc, acc 에만 해당
a[abc]c

//aac, abc, acc ... , azc에 해당
a[a-z]c

//여러 범위를 조합할 수도 있음
//aac, ... ,azc는 물론 aAc, ..., aZC 와도 일치
a[a-zA-Z]c

  + 연산자는 '하나 이상의 문자'를 뜻하고 * 연산자는 '문자가 0개 이상'임을 의미
  이런 연산자와 [] 연산자를 조합하면 언어에서 쓰이는 거의 모든 토큰의 형식을 정의하는 표현식을 만들 수 있음
//하나 이상의 숫자에 해당, 즉 정수 토큰
[0-9]+

//하나의 문자 또는 언더스코어의 뒤에 문자, 숫자, 언더스코어가 0개 이상 붙는 형태에 해당. 즉 C++의 식별자에 해당
[a-zA-Z_][a-zA-Z0-9_]*
  
  어쨌든 토큰과 토큰에 해당하는 정규표현식의 목록을 만들고 나면 플렉스같은 프로그램에 전달해서 자동으로 어휘 분석기를 생성할 수 있음
  개발자가 작성한 스크립트를 어휘 분석기에 넣어서 토큰으로 분해했다면 다음 단계로 넘어가야함
구문분석(syntax analysis)
  분해한 토큰이 언어의 문법을 제대로 따르고 있는지 확인하는 역할을 수행
  스크립트의 문법을 확인하는 동안 전체 프로그램의구조를 정의하는 트리 형태의 데이터 구조인 추상 구문 트리(AST, Abstract Syntax Tree)
  <img src="/04_AST.jpg">
  그림의 트리를 왼쪽 자식노드, 오른쪽 자식노드, 부모노드의 순서로 후위탐색(post-order traversal)한 결과는 5 6 10 * + 이다.
  중위표기법(infix)으로 5 + 6 * 10 인 수식을 후위표기법(postfix)으로 바꾼 결과와 같음
  후위 표기법은 스택과 찰떡궁합이므로 수식을 후위 표기법으로 표기하면 훨씬 쉽게 계산할 수 있으므로 수식이든 아니든 모든 AST는 구문 분석 후에 후위탐색을 거쳐야함
  AST를 만드는 첫 단계로 언어의 문법을 정의해야 함.
  컴퓨터 언어의 문법을 정의하는 대표적인 방법은 베커스 나우어 표기법(BNF, Backus-Naur Form)을 정의하는 것
  BNF의 형식은 비교적 간단함. 온전한 덧셈, 뺄셈을 수행할 수 있는 계산기의 문법은 다음과 같이 정의할 수 있음
  <정수> ::== [0-9]+
  <수식> ::== <수식>"+"<수식> | <수식>"-"<수식> | <수식>
  ::== 연산자는 '~로 정의한다'라는 뜻, | 연산자는 또는 이라는 뜻, <>는 문법 규칙의 이름을 나타냄
  따라서 앞서 소개한 BNF문법은 수식과  다른 수식을 더하는 수식, 빼는 수식 또는 정수로만 이루어진 수식을 나타냄
  즉 5+6은 타당한 수식임. 5,6은 정수고 각각 정수로만 이뤄진 수식에 해당하므로 두 수식을 더할 수 있기 때문
  토큰화와 마찬가지로 구문 분석을 도와주는 툴도 존재. 바이슨(bison)같은 툴을 사용하면 문법 규칙이 일치할 때마다 원하는 C, C++ 동작을 실행하게 만들 수 있음
  일반적으로 이런 동작을 처리하는 방법은 AST에 적절한 노드를 생성하느 것.
  예를 들어 덧셈과 일치하는 수식을 발견하면 왼쪽, 오른쪽 피연산자를 자식 노드로 지니는 덧셈노드를 생각할 수 있음
  즉, 각 노드의 형식과 일치하는 클래스를 만드는 방법이 최선이라는 뜻. 따라서 덧셈, 뺄셈 문법에는 수식을 추상화한 기본 클래스와 정수노드, 덧셈노드, 뺄셈노드에 해당하는 클래스 등
  총 네 개의 클래스가 필요함. 클래스의 계층은 다음과 같음
  <img src="/05_class.jpg">
코드 실행 또는 코드 생성 
  스크립트 파일에서 AST를 만들고 나면 이제 둘 중 하나의 과정을 거쳐야만 함. 어쨌든 둘 다 후위탐색이 필요함
  전통적인 방식의 컴파일러에서 AST탐색의 목표는 타겟 기기에서 실행할 실제 코드를 만들어내는 것
  C++컴파일러는 AST를 탐색하면서 타겟 플랫폼에서 작동할 수 있는 어셈블리 코드를 만들어냄
  앞서 말했듯이 언리얼스크립트같은 게임 스크립트 언어는 컴파일할 때 코드를 생성하는 과정을 거침. 하지만 인터프리터 언어라면 코드 생성 과정이 필요 없음
  AST탐색은 단순히 탐색으로 끝내고 노드가 나타내는 동작을 실행하는 쪽이 바람직
  덧셈, 뺄셈의 예에서 노드는 다음과 같이 정의할 수 있음
abstract class Expression
  function Execute()
end

class Integer inherits Expression
  //정수 값을 저장
  int value
  
  //생성자
  ...
  
  function Execute()
    //연산 스택에 값을 푸시
    ...
  end
end

/Addition(덧셈)노드
class Addition inherits Expression
  //왼쪽, 오른쪽 피연산자
  Expression lhs, rhs
  
  //생성자
  ...
  
  function Execute()
    //후위탐색이란 왼쪽, 오른쪽, 자신의 순서로 탐색한다는 뜻
    lhs.Execute()
    rhs.Execute()
    
    //연산 스택의 맨 위에 있는 두 값을 더한 뒤에 더한 결과를 스택에 푸시
    ...
  end
end
//Substraction(뺄셈) 노드는 연산이 뺄셈이라는 점을 제외하면 덧셈노드와 똑같음
...

  이 클래스를 사용하면 루트 노드에서 Execute를 호출해 AST의 결과를 계산할 수 있음. 함수가 리턴한 뒤에 스택 안에 홀로 남아있는 값은 연산결과에 해당
  예시)5+6 연산
    AST에서 루트노드가 Addition 클래스고 왼쪽 자식노드는 값이 5인 Integer클래스, 오른쪽 자식노드는 값이 6인 Integer클래스로 이뤄짐
    따라서 루트노드인 Addition 노드에서 Execute를 호출하면 먼저 왼쪽노드 5에서 Execute를 호출해 연산 스택에 5를 푸시
    그런 다음 노드 6에서 연산 스택에 6을 푸시. 마지막으로 루트 노드의 Execute에서 스택의 맨 위 두 값을 더한 뒤에 최종 결과인 11을 다시 스택에 푸시
  물론 실제 스크립트 언어는 기초적인 수학 계산 이상의 다양한 기능을 지원하므로 Execute함수가 훨씬 복잡해질 것. 하지만 아무리 언어의 문법이나 노드 형식이 복잡해도 후위탐색이라는 원칙은 유지
  
데이터 형식 
  그 밖에도 게임을 개발하는 동안 저장해야할 데이터를 표현할 방법을 결정해야함
  간단한 게임이라면 데이터를 하드코딩할 수 있지만 좋은 방법이 아님. 데이터를 별도의 파일에 저장하면 프로그래머가 아니어도 수정할 수 있다는 장점이 있음
  또한 데이터를 훨씬 쉽게 다룰 수 있는 레벨 편집기같은 툴 프로그램을 만드는 방법도 생각해볼 가능성이 열림
  데이터 형식을 결정하려면 먼저 데이터를 바이너리로 저장할지 텍스트로 저장할지 결정해야함
    바이너리 파일에는 사람이 읽을 수 없는 형태의 데이터가 들어있음. 예시)이미지파일 형식
    텍스트 파일은 표준 아스키문자로 이루어져 있어 사람이 읽을 수 있음
  사용할 스크립트 언어를 결정할 때와 마찬가지로 각 형식의 장단점을 따져봐야함
각 형식의 장단점
  바이너리 파일의 장점은 파일의 크기가 작아진다는 것과 더 빨리 로드할 수 있다는 것에 있음
  텍스트 파일은 파싱해서 메모리에 올릴 수 있는 형태로 변환하려면 시간이 걸리지만 바이너리 파일은 대개 변환 없이 바로 메모리에 올릴 수 있음
  게임에서는 효율성이 매우 중요하므로 레벨 구성 정보처럼 용량이 큰 정보를 저장해야할 파일이라면 바이너리로 저장하는 것이 효율적임
  속도 면에서는 장점이 있지만 단점도 있음. 바이너리 파일은 버전 관리 시스템과 함께 사용하기 어려움
  바이너리 파일을 수정했을 때 원ㄹ ㅐ파일과 수정한 파일의 차이점을 알아내기가 쉽지않기때문
  예시) 언리얼의 .pkg파일 같은 바이너리 파일에 레벨 데이터를 저장해 게임을 개발 중인데 레벨 디자이너가 레벨 편집기를 사용해서 레벨의 열 군데를 수정한 뒤에 업데이트 했다고 가정
    갑자기 레벨을 로드할 수 없는 문제가 발생해서 버그를 찾아내야하지만 바이너리파일에서 문제가 있는 부분을 집어낼 방법이 없으므로 수정할 내용을 전부 되돌릴 수 밖에 없음
    하지만 텍스트 파일 형식이라면 파일의 차이점을 매우 쉽게 확인하여 열 군데 중 문제인 한 군데를 찾아서 그 부분만 되돌릴 수 있었을 것
  텍스트 파일 형식은 사용자가 직접 수정할 수 있다는 장점이 있음. 하지만 레벨 데이터를 텍스트로 저장하면 플레이어가 멋대로 레벨데이터를 수정해서 게임을 망칠 수 있음
  같은 데이터를 텍스트와 바이너리로 동시에 표현하는 방법이 있음. 개발 중에는 수정 내용을 쉽게 추적할 수 있어야 편하므로 레벨과 게임오브젝트 데이터를 모두 텍스트로 저장하면서 개발을 진행함
  실제로 배포할 때는 베이크(bake)라는 과정을 통해 텍스트 데이터를 효율적인 바이너리 형식으로 변환함
  이 바이너리 파일은 절대 버전 관리 시스템에 올라가지 않으며 개발자가 다루는 데이터는 텍스트 형식의 데이터 뿐
  즉, 개발 중에는 텍스트 파일의 장점을 살릴 수 있고 배포할 때는 바이너리 파일의 장점을 살릴 수 있음
  이때 테스트에 신경써서 개발팀은 텍스트 형식으로 수정할 내용을 바이너리로 바꿨을 때 문제를 일으키지 않는지 
  




