## 전통적인 게임 루프
* 입력처리, 게임세계 업데이트, 출력 생성의 세 단계로 뚜렷하게 나뉜다
```
while game is running
  process inputs
  update game world
  generate outputs
loop
```

### 입력처리
* 키보드, 마우스, 컨트롤러, 멀티플레이에서의 외부입력 등의 모든 입력
### 게임세계 업데이트
* 게임 내에서 활동 중인 모든 게임 오브젝트를 업데이트 처리
### 출력생성단계
* 오디오 출력, 시각적 출력, 포스 피드백, 네트워크 데이터
  
### 멀티스레드 게임 루프
* 멀티코어 CPU에서 다중 프로세스를 진행할 수 있는 게임루프를 만드는 것이 중요
```
예시)
화면 전체 렌더링에 30ms, 게임세계 업데이트에 20ms가 걸리는 게임
싱글코어 게임루프에서는 1 frame당 50ms가 소요되므로 게임은 20FPS
하지만 멀티스레드 게임루프를 이용하여 렌더링과 업데이트를 동시에 진행하면 30ms 소요되므로 30FPS로 성능향상 가능
문제가 발생 : 렌더링 스레드가 화면을 그리는 동안 메인스레드는 무엇을 해야 하는가?
둘로 나눈 스레드의 효과를 제대로 살리려면 렌더링 스레드를 메인 스레드보다 한 frame늦게 수행해야함
즉 메인 스레드가 업데이트를 수행하는 동안 렌더링 스레드는 메인 스레드가 전 frame에서 업데이트한 결과를 화면에 그려야함
이렇게 할 경우 플레이어의 입력을 화면에 반영하는데 걸리는 시간인 입력 지연시간(input lag)가 늘어날 수 있다는 단점이 존재
```
### 실제시간과 게임시간
* 실제시간(real time) : 현실 세계에서 흘러간 시간
* 게임시간(game tiem) : 게임 세계에서 흘러간 시간
* 개발자는 게임시간을 적절히 조절하여 게임의 재미나 템포를 조절할 수 있음
* 예) 맥스페인 bullet time, 피파의 90분과 현실의 90분의 차이
### 델타시간
* 게임개발초기에는 프로세서의 속도를 한 가지로 가정하고 프로그래밍 할 때가 있었음
  * 하지만 이는 속도가 다른 프로세서에서 게임을 동작할 경우 FPS가 달라지는 결과를 초래함
* 이동, 회전, 확대와 같은 요소를 계산할 때는 프레임당 몇 픽셀단위가 아닌 초당 몇 픽셀단위로 생각할 필요가 있음
  * 예) player.position.x += 5 --> player.position.x += 150*deltaTime
* 각 프레임에 적용할 델타시간값을 구하려면 전 프레임을 수행하는데 걸린 실제 경과 시간을 파악하여 게임시간으로 변환해야한다
### 델타타임을 적용한 게임루프
```
while game is running
  realDeltaTime = time since last frame
  gameDeltaTime = realDeltaTime * gameTimeFactor
  
  // 입력처리
  ...
  
  update game world with gameDeltaTime
  
  // 출력생성
  ...
loop
```
* 하지만 이러한 코드도 물리학이 적용되면 수치적분의 특성때문에 프레임 속도에 따라 움직임 자체가 완전히 달라질 수 있다
* 이를 해결하는 간단한 방법은 목표로 설정한 델타시간이 지날 때까지 게임 루프를 강제로 대기시키는 프레임제한을 구현하는 것이다
* 예시) 30FPS에서 30ms안에 프레임의 모든 로직을 완료했다면, 바로 다음 프레임으로 넘어가지 않고 3.3ms를 대기시켜 30FPS를 맞추는 것
### 프레임 제한을 적용한 게임루프
```
targetFrameTime = 33.3f // 30FPS
while game is running
  realDeltaTime = time since last frame
  gameDeltaTime = realDeltaTime * gameTimeFactor
  
  // 입력처리
  ...
  
  update game world with gameDeltaTime
  
  // 출력생성
  ...
  while(time spent this frame) < targetFrameTime
    // 시간을 보내는 작업
    ...
  loop
loop
```
### 프레임 드랍
* 복잡한 게임에서 프레임의 수행시간이 목표시간을 넘어가는 경우 이전 프레임의 렌더링을 건너뛰는 방법
* 눈에 띄는 부자연스러움이 생김
  
### 게임오브젝트
* 움직이는 모든 오브젝트 : 업데이트+그리기, 예시)플레이어, 적 오브젝트
* 정적 오브젝트 : 그리기, 예시)건물, 배경
* 트리거 오브젝트 : 감지할 수 있도록 꾸준히 업데이트, 예시)카메라, 닿으면 적이 나타나는 포인트
  
## 연습문제
1. 초기 콘솔 게임이 어셈블리어로 만들어진 이유?
>초기 콘솔은 메모리와 연산능력이 부족하였고, 고급 언어를 제대로 활용할 수 있는 개발 툴이 없었기 때문
2. 미들웨어란?
>써드파티가 게임의 특정 문제를 해결하려고 만든 코드 라이브러리. 물리시스템 구현의 번거로움 등...
3. 클래식 아케이드 게임 중 하나를 골라서 전통적인 게임 루프를 사용했다고 가정하고 게임 루프의 세 단계에서 해야할 일을 각각 설명해보라
4. 전통적인 게임 루프에서 그래픽을 제외한 다른 출력의 예를 들어보라
5. 기본적인 멀티스레드 게임 루프에서 프레임 속도를 높이는 방법?
6. 입력 지연이란? 그리고 멀티스레드 게임 루프에서 입력 지연이 발생하는 이유는?
7. 실제 시간과 게임 시간의 차이점은? 그리고 게임시간과 실제시간은 언제 달라질 수 있는가?
8. 30FPS에서 정상적으로 동작하는 다음 코드를 프레임 속도에 의존하지 않는 코드로 수정하라
9. 전통적인 게임루프에서 게임의 속도를 30FPS로 고종하는 방법은?
10. 게임 오브젝트의 종류 세가지를 설명
