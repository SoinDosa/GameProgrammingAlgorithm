실제 AI와 게임의 AI
  전통적인 컴퓨터과학 분야에서 인공지능에 관한 연구는 유전자 알고리즘, 신경망처럼 점점 형태가 복잡해지는 방향으로 가고 있음
  하지만 이런 복잡한 알고리즘은 컴퓨터, 비디오 게임에 사용하는 데 한계가 있음.
    첫 번째, 복잡한 AI알고리즘은 엄청난 연산시간이 필요한데 게임에서 AI연산에 쓸 수 있는 시간은 전체 프레임 시간의 일부 뿐임
    두 번째, 게임 AI는 일반적으로 디자이너의 요청에 따라 명확한 요구사항이나 행동을 지니지만 전통적인 AI는 더욱 모호하고 보편적인 문제를 해결하는데 초점을 맞추고 있기 때문
  대다수 게임의 AI는 간단한 상태 머신 규칙의 조합에 약간의 무작위적인 요소를 추가한 정도의 수준
  하지만 예외로 체스나 바둑처럼 복잡한 보드게임의 AI를 구현하려면 전통적인 게임 이론의 초석인 의사 결정 트리가 필요.
  하지만 동시에 처리해야 할 움직임의 수가 상대적으로 적은 보드게임과 비디오 게임은 완전히 다름
  일반적으로 게임의 AI는 지능이 느껴지는 정도면 충분함
길찾기
  게임 세계 안에 A와 B라는 위치가 있을 때 두 위치 사이를 지능적으로 이동하는 경로를 찾는 방법
  이 문제가 생각보다 복잡한 이유는 A와 B사이에 다양한 경로가 있을 수 있지만, 객관적으로 봤을 때 최선의 경로는 단 하나뿐이기 때문
  단순히 두 점 사이의 경로를 찾는 것이 전부가 아니라 이상적인 길 찾기 알고리즘이라면 모든 가능성을 따져본 뒤에 가장 확실한 최선의 경로를 찾아야 함
탐색공간 표현
  길 찾기 알고리즘을 가장 쉽게 구현하는 방법은 그래프 데이터 구조를 사용하는 것
    그래프 : 엣지(edge)를 통해 인접한 다른 노드(node)와 연결할 수 있는 노드의 모음
    이를 구현하는 방법은 다양하지만 가장 기본적인 방법은 인접리스트(adjacency list)
    각 노드에 자신과 인접한 노드를 가리키는 포인터의 리스트인 인접 리스트를 넣는 것
    이렇게 구현하면 그래프의 모든 노드를 기본적인 데이터 구조에 저장할 수 있음
    <img src="/01_adjacency_list.jpg">
  즉 게임에서 길 찾기를 구현하려면 먼저 게임 세계를 그래프로 표현할 방법을 정해야 함
  가장 간단한 방법은 게임 세계를 사각형 또는 육각형 격자로 나누는 것. 이때 인접 노드는 격자 내의 인접한 사각형 또는 육각형
  격자 형태로 나누는 방법은 <문명>이나 <엑스컴>과 같은 턴 방식의 전략 게임에서 매우 흔히 쓰이는 방법
  하지만 대부분으로 실시간 액션게임의 NPC는 사각형 칸에 딱딱 맞춰서 움직이지 않음. 따라서 대부분의 게임은 경로 노드(path node)나 네비게이션 메시(navigation mesh)중 하나를 사용
  어느 쪽이든 레벨편집 프로그램을 사용해서 직접 경로 데이터를 만들 수 있음
  하지만 경로 데이터를 일일히 입력하는 작업은 번거롭기도 하고 실수가 잦을 수 있는 작업이므로 대부분의 게임엔진은 일종의 자동화 기능을 제공함
  경로 데이터를 자동으로 생성하는 알고리즘은 이 책에서 설명할 범위를 벗어남
경로노드(path node)
  경로 노드는 1990년대 초 id 소프트웨어가 발표한 FPS를 시작으로 널리 퍼졌음
  경로노드를 만들려면 레벨 디자이너가 직접 게임 세계의 각 위치에 경로로 사용할 노드를 배치해야함. 물론 노드의 위치는 AI오브젝트가 갈 수 있는 곳이어야 함
  이렇게 만든 경로 노드는 그대로 그래프의 노드로 변환할 수 있음. 엣지는 자동화 기능을 사용해서 만들 수 있음
  자동화 기능을 사용하면 먼저 상대적으로 가까운 노드 사이의 경로가 가로막혀 있는지 확인한 뒤에 가로막히지 않은 두 노드 사이에 엣지를 만들어주므로 디자이너가 하나하나 연결할 필요가 없음
  경로 노드의 가장 큰 문제점은 노드 또는 엣지상의 위치로만 이동할 수 있다는 점
    경로도느가 삼각형으로 이어졌다고 할 때 삼각형 안쪽에 장애물이 있을 수도 있지만, 삼각형의 안쪽이 이동할 수 있는 위치인지 확인할 방법이 없음
  따라서 경로노드를 사용하는 길 찾기 알고리즘은 노드나 엣지상의 위치가 아니면 전부 가지 못하는 곳으로 간주하는데,
  이로 인해 가지 못하는 곳이 매우 많아지거나 경로노드가 엄청나게 많아져서 AI의 움직임이 부자연스러워지거나, 알고리즘의 결과를 계산하는 시간이 오래걸리는 문제가 발생
    결국 경로노드를 사용하려면 성능과 정확성 둘 중 하나를 포기해야함
네비게이션 메시(navigation mesh)
  경로노드의 대안으로 네비게이션 메시가 있음
  네비게이션 메시에서는 그래프의 각 노드가 하나의 볼록폴리곤에 해당. 인접한 노드는 바로 인접한 볼록폴리곤
  즉 게임 세계의 모든 지역을 적은 수의 볼록 폴리곤으로 표현할 수 있으며 결과적으로 그래프 내의 노드 수를 줄일 수 있다는 뜻
  <img src="/02_difference.jpg">
  네비게이션 메시에서 하나의 노드에 해당하는 볼록 폴리곤의 안쪽은 전부 AI가 갈 수 있는 위치. 즉 AI가 돌아다닐 수 있는 공간을 많이 확보할 수 있으며 결과적으로 더 자연스러운 경로를 얻음
  예시) 소와 닭이 농장을 돌아다니는 게임을 만들때, 닭이 소보다 작으므로 소는 갈 수 없는 지역이 있음
  경로 노드를 사용하면 닭과 소에 관한 그래프를 따로 마련해야하지만 네비게이션 메시는 볼록폴리곤이므로 약간의 계산만으로 소가 갈 수 있는 곳인지 아닌지 확일할 수 있음
  네비게이션 메시는 완전히 자동으로 만들 수 있다는 장점이 있음. 이는 경로노드의 입지를 좁아지게하는 결과를 만듬
사실 탐색공간의 표현 방식은 길 찾기 알고리즘의 구현 방식에 영향을 주지않음. 탐색 공간을 그래프로 표현할 수만 있다면 길 찾기를 시도할 수 있음
바로 뒤에 소개할 예제는 탐색 공간으로 간단한 사각형 격자를 사용하지만 탐색공간이 사각형 격자든, 경로 노드든, 내비게이션 메시든 상관 없이 길 찾기 알고리즘은 바뀌지 않음

허용 가능한 휴리스틱(heuristic)
  휴리스틱 : 이미 정해진 알고리즘에 의해 해법을 구하는 방식이 아니라 정보가 완전하지 못한 상황에서 시행착오를 거치거나 경험을 통해 해법을 추측해내는 방식
    알고리즘과 달리 완벽한 해법을 찾는다는 보장은 없지만 모든 경우의 수를 따지지 않고 시행착오나 경험을 통해 걸너낸 제한적인 경우에 관한 해법을 찾으므로 훨씬 효율적이라는 장점이 있음
  모든 길 찾기 알고리즘은 수학적 평가를 통해 다음에 선택해야 할 노드를 결정함. 게임에 쓰이는 알고리즘은 대부분 h(x)로 나타내는 휴리스틱을 사용
  이는 한 노드에서 최종 노드로 가는 비용을 평가하는 방법. 가능하면 휴리스틱의 결과는 최대한 실제 비용에 가까워야함.
  휴리스틱의 결과가 항상 실제 비용과 같거나 실제 비용보다 적다면 허용 가능(admissible)하다고 간주
  휴리스틱의 평가 결과가 실제 비용보다 크다면 길찾기 알고리즘이 최선의 경로를 찾아낼 확률이 없다고 생각해도 좋음
  <img src="/03_heuristic.jpg">
  사각형 격자의 휴리스틱 계산 방법은 두가지
    첫 번째. 맨해튼 거리(Manhattan distance)는 쭉 뻗은 대도시에서 블록을 따라 이동하는 방법과 비슷
      이는 대각선 방향의 이동이 불가능하다고 가정한 알고리즘이므로 대각선으로 이동할 수 없는 상황에서만 사용해야함
      대각선 방향으로 이동할 수 있을 때 맨해튼 거리를 사용하면 실제 비용이 너무 크게 나오곤 함
      2D 격자에서 맨해튼 거리를 계산하는 공식
      h(x) = |start.x - end.x| + |start.y - end.y|
ㅓ    ㄷ
    
    
    
    
