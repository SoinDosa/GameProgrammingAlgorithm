실제 AI와 게임의 AI
  전통적인 컴퓨터과학 분야에서 인공지능에 관한 연구는 유전자 알고리즘, 신경망처럼 점점 형태가 복잡해지는 방향으로 가고 있음
  하지만 이런 복잡한 알고리즘은 컴퓨터, 비디오 게임에 사용하는 데 한계가 있음.
    첫 번째, 복잡한 AI알고리즘은 엄청난 연산시간이 필요한데 게임에서 AI연산에 쓸 수 있는 시간은 전체 프레임 시간의 일부 뿐임
    두 번째, 게임 AI는 일반적으로 디자이너의 요청에 따라 명확한 요구사항이나 행동을 지니지만 전통적인 AI는 더욱 모호하고 보편적인 문제를 해결하는데 초점을 맞추고 있기 때문
  대다수 게임의 AI는 간단한 상태 머신 규칙의 조합에 약간의 무작위적인 요소를 추가한 정도의 수준
  하지만 예외로 체스나 바둑처럼 복잡한 보드게임의 AI를 구현하려면 전통적인 게임 이론의 초석인 의사 결정 트리가 필요.
  하지만 동시에 처리해야 할 움직임의 수가 상대적으로 적은 보드게임과 비디오 게임은 완전히 다름
  일반적으로 게임의 AI는 지능이 느껴지는 정도면 충분함
길찾기
  게임 세계 안에 A와 B라는 위치가 있을 때 두 위치 사이를 지능적으로 이동하는 경로를 찾는 방법
  이 문제가 생각보다 복잡한 이유는 A와 B사이에 다양한 경로가 있을 수 있지만, 객관적으로 봤을 때 최선의 경로는 단 하나뿐이기 때문
  단순히 두 점 사이의 경로를 찾는 것이 전부가 아니라 이상적인 길 찾기 알고리즘이라면 모든 가능성을 따져본 뒤에 가장 확실한 최선의 경로를 찾아야 함
탐색공간 표현
  길 찾기 알고리즘을 가장 쉽게 구현하는 방법은 그래프 데이터 구조를 사용하는 것
    그래프 : 엣지(edge)를 통해 인접한 다른 노드(node)와 연결할 수 있는 노드의 모음
    이를 구현하는 방법은 다양하지만 가장 기본적인 방법은 인접리스트(adjacency list)
    각 노드에 자신과 인접한 노드를 가리키는 포인터의 리스트인 인접 리스트를 넣는 것
    이렇게 구현하면 그래프의 모든 노드를 기본적인 데이터 구조에 저장할 수 있음
    <img src="/01_adjacency_list.jpg">
  즉 게임에서 길 찾기를 구현하려면 먼저 게임 세계를 그래프로 표현할 방법을 정해야 함
  가장 간단한 방법은 게임 세계를 사각형 또는 육각형 격자로 나누는 것. 이때 인접 노드는 격자 내의 인접한 사각형 또는 육각형
  격자 형태로 나누는 방법은 <문명>이나 <엑스컴>과 같은 턴 방식의 전략 게임에서 매우 흔히 쓰이는 방법
  하지만 대부분으로 실시간 액션게임의 NPC는 사각형 칸에 딱딱 맞춰서 움직이지 않음. 따라서 대부분의 게임은 경로 노드(path node)나 네비게이션 메시(navigation mesh)중 하나를 사용
  어느 쪽이든 레벨편집 프로그램을 사용해서 직접 경로 데이터를 만들 수 있음
  하지만 경로 데이터를 일일히 입력하는 작업은 번거롭기도 하고 실수가 잦을 수 있는 작업이므로 대부분의 게임엔진은 일종의 자동화 기능을 제공함
  경로 데이터를 자동으로 생성하는 알고리즘은 이 책에서 설명할 범위를 벗어남
경로노드(path node)
  경로 노드는 1990년대 초 id 소프트웨어가 발표한 FPS를 시작으로 널리 퍼졌음
  경로노드를 만들려면 레벨 디자이너가 직접 게임 세계의 각 위치에 경로로 사용할 노드를 배치해야함. 물론 노드의 위치는 AI오브젝트가 갈 수 있는 곳이어야 함
  이렇게 만든 경로 노드는 그대로 그래프의 노드로 변환할 수 있음. 엣지는 자동화 기능을 사용해서 만들 수 있음
  자동화 기능을 사용하면 먼저 상대적으로 가까운 노드 사이의 경로가 가로막혀 있는지 확인한 뒤에 가로막히지 않은 두 노드 사이에 엣지를 만들어주므로 디자이너가 하나하나 연결할 필요가 없음
  경로 노드의 가장 큰 문제점은 노드 또는 엣지상의 위치로만 이동할 수 있다는 점
    경로도느가 삼각형으로 이어졌다고 할 때 삼각형 안쪽에 장애물이 있을 수도 있지만, 삼각형의 안쪽이 이동할 수 있는 위치인지 확인할 방법이 없음
  따라서 경로노드를 사용하는 길 찾기 알고리즘은 노드나 엣지상의 위치가 아니면 전부 가지 못하는 곳으로 간주하는데,
  이로 인해 가지 못하는 곳이 매우 많아지거나 경로노드가 엄청나게 많아져서 AI의 움직임이 부자연스러워지거나, 알고리즘의 결과를 계산하는 시간이 오래걸리는 문제가 발생
    결국 경로노드를 사용하려면 성능과 정확성 둘 중 하나를 포기해야함
네비게이션 메시(navigation mesh)
  경로노드의 대안으로 네비게이션 메시가 있음
  네비게이션 메시에서는 그래프의 각 노드가 하나의 볼록폴리곤에 해당. 인접한 노드는 바로 인접한 볼록폴리곤
  즉 게임 세계의 모든 지역을 적은 수의 볼록 폴리곤으로 표현할 수 있으며 결과적으로 그래프 내의 노드 수를 줄일 수 있다는 뜻
  <img src="/02_difference.jpg">
  네비게이션 메시에서 하나의 노드에 해당하는 볼록 폴리곤의 안쪽은 전부 AI가 갈 수 있는 위치. 즉 AI가 돌아다닐 수 있는 공간을 많이 확보할 수 있으며 결과적으로 더 자연스러운 경로를 얻음
  예시) 소와 닭이 농장을 돌아다니는 게임을 만들때, 닭이 소보다 작으므로 소는 갈 수 없는 지역이 있음
  경로 노드를 사용하면 닭과 소에 관한 그래프를 따로 마련해야하지만 네비게이션 메시는 볼록폴리곤이므로 약간의 계산만으로 소가 갈 수 있는 곳인지 아닌지 확일할 수 있음
  네비게이션 메시는 완전히 자동으로 만들 수 있다는 장점이 있음. 이는 경로노드의 입지를 좁아지게하는 결과를 만듬
사실 탐색공간의 표현 방식은 길 찾기 알고리즘의 구현 방식에 영향을 주지않음. 탐색 공간을 그래프로 표현할 수만 있다면 길 찾기를 시도할 수 있음
바로 뒤에 소개할 예제는 탐색 공간으로 간단한 사각형 격자를 사용하지만 탐색공간이 사각형 격자든, 경로 노드든, 내비게이션 메시든 상관 없이 길 찾기 알고리즘은 바뀌지 않음

허용 가능한 휴리스틱(heuristic)
  휴리스틱 : 이미 정해진 알고리즘에 의해 해법을 구하는 방식이 아니라 정보가 완전하지 못한 상황에서 시행착오를 거치거나 경험을 통해 해법을 추측해내는 방식
    알고리즘과 달리 완벽한 해법을 찾는다는 보장은 없지만 모든 경우의 수를 따지지 않고 시행착오나 경험을 통해 걸너낸 제한적인 경우에 관한 해법을 찾으므로 훨씬 효율적이라는 장점이 있음
  모든 길 찾기 알고리즘은 수학적 평가를 통해 다음에 선택해야 할 노드를 결정함. 게임에 쓰이는 알고리즘은 대부분 h(x)로 나타내는 휴리스틱을 사용
  이는 한 노드에서 최종 노드로 가는 비용을 평가하는 방법. 가능하면 휴리스틱의 결과는 최대한 실제 비용에 가까워야함.
  휴리스틱의 결과가 항상 실제 비용과 같거나 실제 비용보다 적다면 허용 가능(admissible)하다고 간주
  휴리스틱의 평가 결과가 실제 비용보다 크다면 길찾기 알고리즘이 최선의 경로를 찾아낼 확률이 없다고 생각해도 좋음
  <img src="/03_heuristic.jpg">
  사각형 격자의 휴리스틱 계산 방법은 두가지
    첫 번째. 맨해튼 거리(Manhattan distance)는 쭉 뻗은 대도시에서 블록을 따라 이동하는 방법과 비슷
      이는 대각선 방향의 이동이 불가능하다고 가정한 알고리즘이므로 대각선으로 이동할 수 없는 상황에서만 사용해야함
      대각선 방향으로 이동할 수 있을 때 맨해튼 거리를 사용하면 실제 비용이 너무 크게 나오곤 함
      2D 격자에서 맨해튼 거리를 계산하는 공식
      <img src="/04_Manhattan_distance.jpg">
    두 번째. 유클리드 거리(Euclidean distance)는 기본적인 직선의 거리 공식을 사용해서 하늘을 가로질러 가는 경로를 평가함
      맨해튼 거리와 달리 탐색 공간을 경로 노드나 내비게이션 메시로 표현했을 때도 사용할 수 있음
      맨해튼 거리의 예와 똑같은 2D격자에서 유클리드 거리를 계산하는 공식
      <img src="/05_Euclidean_distance.jpg">
탐욕적 최상 우선 알고리즘(greedy best-first search)
  휴리스틱을 사용하면 비교적 기본적인 길 찾기 알고리즘은 탐욕적 최상 우선 탐색을 구현할 수 있다
  장기적인 계획 없이 당장 최선의 해답을 택하는 알고리즘을 의미. 단계마다 모든 인접 노드를 확인해서 휴리스틱 값이 가장 낮은 노드를 선택
  괜찮은 해법처럼 보일지 몰라도 탐욕적 최상 우선 알고리즘의 결과는 최선책이 아닌 차선책일 때가 많음
  <img src="/06_greedy_search.jph">
  녹색 : 시작노드, 빨간색 : 종료노드, 회색 : 장애물
  이 경로를 보면 시작하자마자 캐릭터가 쓸데없이 오른쪽으로 이동, 시작 노드에서 계산했을 때 오른쪽이 최선의 노드이기 때문, 이상적인 경로는 출발점에서 바로 아래로 향하는 것
  이런 경로를 구하려면 탐욕적 최상 우선 알고리즘에는 없는 특징인 일종의 계획이 필요함
  탐욕적 최상 우선 알고리즘 구현
    먼저 각 노드를 저장하는 데 필요한 데이터를 살펴보자. 그래프 구성에 필요한 인접 노드 정보와 함께 저장해야하는 데이터다. 여기서 구현할 알고리즘은 두 개의 데이터가 필요
struct Node 
  Node parent
  float h
end
    parent멤버 변수는 현재 노드 전에 방문한 노드를 추적하는 용도로 쓰임. parent는 C++같은 언어에서는 포인터, C#과 같은 언어에서는 참조로 넘겨받은 클래스여야함
    parent가 중요한 이유는 최종 노드에서 시작노드로 거슬러 올라가며 연결리스트를 만드는데 쓰이기 때문
    알고리즘 계산이 끝나고 나면 parent연결리스트를 확인해서 최종 경로를 재구성해야함
    float 변수인 h에는 해당 노드에 관해 계산한 h(x)값을 저장. 나중에 가장 낮은 h(x)값을 지닌 노드를 선택할 때 참고할 값임
    그리고 임시로 노드를 저장할 개집합(open set)과 폐집함(closed set), 두 개의 컨테이너가 필요
      개집합 : 폐집합의 여집합으로 이론상 모든노드를 저장할 수 있으나 당장 고려해야 할 노드만 저장하는 컨테이너
      개집합에는 당장 고려해야 할 모든 노드를 저장
      이 알고리즘에서 h(x)의 비용이 제일 낮은 노드를 찾는 연산은 빈번하게 일어나므로 바이너리 힙이나 우선수위 큐처럼 값을 정령해서 저장할 수 있는 컨테이너를 개집합으로 사용하면 좋음
      폐집합 : 이미 연산이 끝난 결과를 저장하는 컨테이너
      폐집합에는 이미 알고리즘을 통해 평가가 끝난 노드를 저장. 폐집합 안의 노드는 알고리즘에서 고려해야할 대상에서 제외
      노드가 폐집합에 들어있는지 확인
    노드가 폐집합에 들어있는지 확인하는 연산은 자주 수행해야 하므로 이진 검색트리처럼 검색에 필요한 시간 복잡도가 O(n)보다 나은 데이터 구조를 사용해야함
  이제 탐욕적 최상 우선 알고리즘에 필요한 요소를 모두 갖췄음. 시작 노드와 종료 노드가 있을 때 둘 사이의 경로를 계산하고 싶을 때, 알고리즘의 계산은 대부분 루프 안에서 이뤄짐
  하지만 루프에 들어가기 전에 다음과 같이 데이터를 초기화해야함
currentNode = startNode
add currentNode to closeSet 
  currentNode는 다음에 이웃 노드를 평가할 노드를 나타냄. 알고리즘을 처음 시작할 때는 경로 내에 시작노드밖에 없으므로 당연히 시작노드의 이웃노드를 먼저 평가해야함
  메인 루프에서 가장 먼저 할 일은 현재 노드와 인접한 모든 노드를 확인해서 개집합에 추가하는 것
do 
  foreach Node n adjacent to currentNode
    if closeSet contains n
      continue
    else
      n.parent = currentNode
      if openSet does not contain n
        compute n.h
        add n to openSet
      end
    end
  loop // foreach루프의 끝
  
  이미 폐집합에 들어있는 노드를 무시한다는 점에 주목. 폐집합의 노드는 이미 평가가 끝났으므로 더 평가할 필요가 없음
  폐집합의 노드를 확인한 뒤에 다른 모든 인접 노드의 parent를 현재 노드로 설정. 그런 다음 현재 노드가 개집합에 없는 노드면 h(x)값을 계산한 뒤에 개집합에 추가함
  인접 노드에 관한 처리가 끝나면 개집합을 확인해야함. 개집합에 노드가 없다면 더는 평가할 노드가 없으며 이는 길찾기 실패를 의미함
  항상 결로를 찾을 수 있다는 보장이 없으므로 길찾기 알고리즘은 실패하는 상황도 대비해야함
if openSet is empty
  break // 메인 루프를 빠져나감
end 
  하지만 개집합에 노드가 남아있다면 계속해서 경로를 찾을 수 있음. 다음으로 해야 할 일은 개집합에서 h(x)의 값이 가장 작은 노드를 찾아 폐집합으로 옮기는 것
  루프를 다시 한 번 돌릴 수 있게 방금 폐집합으로 옮긴 노드를 현재 노드로 설정해야함
currentNode = Node with lowest h in openSet 
remove currentNode from openSet
add currentNode to closedSet
  바로 여기서 값을 정렬해 저장할 수 있는 컨테이너의 유용성이 빛을 발함
  바이너리힙을 사용하면 O(n)이 걸리는 탐색을 하지 않아도 O(1)만에 h(x)가 가장 작은 노드를 얻을 수 있음
  마지막으로 루프를 빠져나오는 조건을 설정. 현재 노드가 최종 노드와 같다면 경로를 찾았다는 뜻이므로 루프를 종료
until currentNode == endNode // 메인 루프인 do...until 종료
  성공적으로 do...until 루프를 빠져나왔다면 최종 노드에서 시작 노드로 거슬러 올라가는 parent의 연결리스트가 만들어짐
  알고리즘을 통해 구하려는 경로는 시작노드에서 최종노드로 가는 경로이므로 리스트를 거꾸로 뒤집어야 함
  리스트를 뒤집는 방법은 다양하지만 가장 쉬운 방법의 하나는 스택을 이용하는 것
  <img src="07_greedy_search_process.jpg">
  해당 그림은 예제 데이터에 탐욕적 최상 우선 알고리즘을 적용해서 두 번의 루프를 수행한 결과를 보여줌. 시작노드를 폐집합에 추가하고 파란색으로 표현한 인접노드를 개집합에 추가함
  각 인접 노드는 맨해튼 거리 휴리스틱으로 계산한 최종 노드까지의 h(x)값을 지님. 그림의 화살표는 자식 노드에서 부모 노드로 향하고 있음.
  그 다음 h(x)값이 가장 작은 노드를 선택함. 그림에서는 h가 3인 노드를 선택함. h=3인 노드를 현재 노드로 설정하고 폐집합에 추가함. 그 다음 이를 반복, 노란색인 현재노드를 개집합에 추가함
  빨간색으로 표현한 최종 노드까지 폐집합에 추가하고나면 최종 노드에서 시작노드로 이어지는 연결 리스트가 만들어짐. 이제 이 리스트를 뒤집으면 경로노드를 얻을 ㅅ ㅜ있음
탐욕적 최상 우선 알고리즘, 알고리즘을 수행하는 도중에 h(x)값이 바뀌지 않는다는 가정하에 구현한 코드라는 점에 주의
currentNode = startNode
add currentNode to closedSet
do
  //인접노드를 개집합에 추가
  foreach Node n adhacent to currentNode
    if closedSet contains n
      continue
    else
      n.parent = currentNode
      if openSet does not contains n
        compute n.h
        add n to openSet
      end
    end
  loop

  //더 평가할 노드가 없음
  if openSet is empty
    break
  end
  //새로운 현재 노드를 선택
  currentNode = Node with lowest h in openSet
  remove currentNode from openSet
  add currentNode to closedSet
until currentNode == endNode

//경로를 구했다면 스택을 사용해서 반대로 뒤집음
if currentNode == endNode
  Stack path
  Node n = endNode
  while n is not null
    push n onto path
    n = n.parent
  loop
else
  //경로를 찾을 수 없음
end
  스택을 사용해서 경로를 다시 거꾸로 구성하고 싶지 않다면 아예 최종노드에서 시작노드로 가는 경로를 계산하는 방법도 있음
  이렇게 하면 연결 리스트가 시작 노드에서 최종 노드의 순서로 만들어지므로 계산 시간을 조금이나마 절약할 수 있음

A*(A star) 길 찾기 알고리즘
  지금까지 탐욕적 최상 우선 알고리즘을 살펴봤는데 여기에 하나의 개념만 추가하면 경로의 품질을 확 끌어올릴 수 있음
  허용가능한 휴리스틱 h(x)에만 의존하지않고 경로비용(path-cost)도 고려하는 알고리즘
    경로비용이란 시작노드에서 현재노드까지의 실제비용을 의미, g(x)로 표시
    A* 알고리즘에서 노드에 도달하는데 드는 비용의 총합을 구하는 방정식은 다음과 같음
    f(x) = g(x) + h(x)
    A* 알고리즘을 적용하려면 다음과 같이 Node 구조체에 f(x)와 g(x)도 저장해야함
struct Node
  Node parent
  float f
  float g
  float h
end
  개집합에 노드를 추가할 때마다 f(x), g(x), h(x)를 모두 계산해야함. 게다가 A*는 매번 가장 낮은 f(x)를 선택하는 알고리즘이므로 개집합을 모든 f(x)에 관해 정렬해서 저장해야함
  A*알고리즘의 코드를 구현할 때 크게 바뀌는 점은 노드 입양(node adoption)이라는 개념 하나뿐
  최상 우선 알고리즘에서 현재노드의 인접노드는 항상 현재 노드를 자신의 부모로 설정해야 했지만
  A*알고리즘에서는 이미 개집합에 들어있는 인접 노드는 현재 노드가 더 나은 부모인지 아닌지 결정할 수 있는 평가값을 지니고있어야함
  이렇게 하는 이유는 부모의 g(x)비용이 노드의 g(x)비용을 좌우하기 때문, 즉 더 적합한 부모가 있다면 노드의 g(x)비용을 낮출 수 있음
  따라서 무조건 노드의 부모를 교체하지 말고 현재 노드가 더 나은 부모일 때만 교체해야함
  <img src="08_a_star.jpg">
  청록색으로 표시한 현재 노드가 인접 노드를 확인하고 있음. 왼쪽에 g=2인 노드가 있는 하늘색 노드를 보면, 이 노드가 청록색 노드를 부모로 삼으면 g=2인 노드의 g가 4로 바뀌면서 비용이 올라감
  따라서 이때 청록색 노드의 입요청은 거부당함. 최종경로를 보면 확실히 개선됨
A*알고리즘, 노드 입양을 제외하면 최상 우선 알고리즘의 코드와 매우 비슷함
currentNode = startNode
add currentNode to closedSet
do
  foreach Node n adjacent to currentNode
    if closedSet contains n
      continue
    else if openSet contains n // 입양 여부 확인
      compute new_g // currentNode가 부모일 때 노드 n의 g(x)값
      if new_g < n.g
        n.parent = currentNode
        n.g = new_g
        n.f = n.g + n.h // 이 노드의 n.h는 앞으로도 바뀌지 않음
      end
    else
      n.parent = currentNode
      compute n.h
      compute n.g
      n.f = n.g + n.h
      add n to openSet
    end
  loop
  
  if openSet is emplty
    break
  end
  
  currentNode = Node with lowest f in openSet
  remove currentNode from openSet
  add currentNode to closedSet

until currentNode == endNode
// 경로를 재구성
...
      
      
    
    
