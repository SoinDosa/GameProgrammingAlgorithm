스크립트언어
  한동안 게임은 기기성능의 최적화를 위해 어셈블리 언어를 사용해옴. 하지만 컴퓨터의 성능이 높아지고 게임이 복잡해지면서 어셈블리로 개발하여 얻는 장점이 완전히 사라짐
  이런 이유로 최신 게임엔진은 모두 C++과같은 고급언어로 만들어짐
  요즈음 게임 플레이에 관한 코드의 많은 부분을 루아, 파이썬, 언리얼스크립트 등 상위 레벨 언어인 스크립트 언어로 작성하는 게임도 많음
  스크립트 코드는 작성하기 쉬우므로 디자이너가 직접 작성할 수 있을때도 있음. 즉 엔진코드를 잘 모르는 디자이너라도 자신의 아이디어를 프로토타이핑할 수 있다는 의미
  AAA게임의 물리 시스템이나 렌더링 시스템처럼 게임 엔진의 언어로 작성할 수밖에 없는 부분도 여전히 남아있긴 하지만 카메라, AI행동 등은 스크립트로도 작성할 수 있음
스크립트언어의 장단점
  스크립트 언어의 성능은 C++과 같은 컴파일 언어의 성능에 미치지 못함
    예시)루아, 파이썬같은 인터프리터 스크립트 언어는 자바나 C#처럼 JIT, 가상마선을 사용하는 언어와 비교해도 성능 면에서 경쟁력이 없음
    인터프리터 언어는 텍스트로 작성한 코드를 미리 컴파일하지 않고 필요할 때 읽어와서 실행하는 방식이기 때문
  코드를 중간상(intermediary)으로 컴파일할 수 있는 스크립트 언어도 존재, 이는 순수 컴파일언어만큼 빠르지는 않지만 대개 인터프리터 언어보다는 빠름
  하지만 여전히 성능의 차이가 있으므로 높은 성능을 요구하는 코드는 스크립트로 구현해선 안됨
  AI중에서도 A*길찾기 알고리즘은 높은 성능을 요구하므로 스크립트로 작성하면 안되지만 AI의 행동을 좌우하는 상태머신은 복잡한 계산이 필요없으므로 스크립트 언어로 작성할 수 있음
  예제 게임에서 스크립트 언어의 용도)
    C++ : 렌더링 엔진, AI(길 찾기), 물리 시스템, 파일로드
    스크립트언어 : 카메라로직, AI(상태 머신), 일반적인 게임 플레이 로직, 사용자 인터페이스
  스크립트 언어의 가장 큰 장점은 각 개발 단계를 빠르게 반복할 수 있다는 점
  예시)AI상태머신을 C++로 작성한 게임을 테ㅐ스트하던 프로그래머가 이상하게 행동하는 적을 발견했다고 가정
    C++코드라면 다양한 툴을 사용해서 문제를 분석해낼 수 있지만 프로그램을 실행 중인 상태에서는 문제를 수정할 수 없음
    대개 프로그래머는 게임을 중단하고 소스 수정->실행파일 빌드->게임다시시작 과정을 거쳐야 문제를 제대로 해결했는지 알 수 있음
    하지만 스크립트 언어로 AI상태머신을 작성했을 경우 똑같은 상황이 벌어지면 게임이 실행 중인 상태더라도 동적으로 AI스크립트를 다시 로드하여 수정한 내용을 반영할 수 있음
    이는 생산성을 매우 높여줌
    또한 C++로 AI행동을 구현한 코드에서 AI코드에 가끔 알 수 없는 포인터에 접근하는 버그가 있다고 가정. 이 버그를 해결하지 못하면 게임이 시스템과 충돌하는 일이 벌어짐
    하지만 상태 머신을 스크립트로 작성했다면 AI르 적용한 캐릭터의 기능이 멎어도 게임의 실행에 영향을 주지 않음
  스크립트는 실행 파일과 상관없는 별도의 파일이므로 내용을 수정한 뒤, 쉽게 배포할 수 있음. 규모가 큰 프로젝트의 실행 파일은 빌드만 몇 분씩 걸릴 수 있고 파일 크기가 100MB에 육박할 수 있음
  또한 새 버전이 나올 때마다 업데이트를 원하는 사용자는 거대한 실행 파일을 통째로 다운로드해야하지만, 스크립트 언어를 사용하면 몇 KB정도의 데이터만 다운로드하면 끝이므로 업데이트 시간이 단축됨
  이렇게 생산성 측면에서 큰 장점이 있으므로 성능에 민감한 부분이 아니라면 스크립트로 작성하는 쪽이 나을 수 있음
  게임에 스크립트 시스템을 추가하는 일 자체가 부담이긴 하지만 개발팀에 속한 모든 개발자의 생산성을 높일 수 있다면 그 정도 노력은 가치가 있음
스크립트 언어의 종류 
  스크립트 언어를 사용하기로 했다면 루아, 파이썬과 같은 기존 스크립트 언어를 사용할지, 아니면 게임엔진의 전용 스크립트 언어를 사용할 지 생각해야함
  예시)언리얼스크립트, 퀘이크C(QuakeC)
  기존 언어를 사용할 때의 장점은 할 일이 훨씬 줄어듬
  스크립트 파서 구현은 시간도 많이 들고 오류가 발생하기 쉬운 복잡한 작업이므로 상대적으로 부실한 전용언어의 파서를 쓰다보면 직접 구현해야 할 기능이 늘어남
  게다가 전용 언어는 기존 언어보다 사용자의 수가 훨씬 적으므로 언어 자체의 오류가 고쳐지지 않고 오랫동안 남아있을  가능성이 큼(예시:연산자 우선순위의 오류)
  그 밖에도 기존 언어는 대개 언어에 관해 대부분의 게임프로그래머보다 많이 알고 있으며 컴파일러와 가상 머신을 훤히 꿰고 있는 개발자가 설계하고 구현한 언어라는 점을 고려해야함
  하지만 기존 스크립트 언어는 게임 어플리케이션에 적합하지 않을 수도 있다는 문제가 존재
  언어의 설계 방식에 따라 성능 문제나 메모리 할당 문제가 있을 수 있고 스크립트 언어와 게임 엔진을 통합하기 어려울 수도 있음
  전용 언어는 게임개발에 중점을 두고 만들어진 언어임
  마지막으로 고려할 점은 기존 스크립트 언에에 능숙한 개발자를 찾기가 쉽다는 것, 이미 루아나 파이썬같은 언어를 잘 알고 있는 프로그래머는 매우 많음
  하지만 특정 회사나 게임 엔진에서만 쓰는 전용 언어를 잘 아는 개발자는 찾기 어려움
루아(Lua)
  요즘 게임에 가장 널리 쓰이는 범용 스크립트 언어, <WOW>, <컴퍼티오브히어로즈>, <그림 판당고> 등에서 사용
  루아가 게임 개발에 많이 쓰이는 이유는 인터프리터가 매우 가볍기 때문. C로 만들어진 루아의 인터프리터는 150KB의 메모리를 차지함
  루아의 함수 호출로 C, C++코드를 실행할 수 있는 네이티브 바인딩이 간단함. 또한 멀티태스킹을 지원하므로 여러 개의 루아 함수를 동시에 실행할 수도 있음
  루아의 문법은 C계열 언어와 비슷한 점도 있고 다른 점도 있음
  행의 끝에 세미콜론을 쓰든 말든 상관하지 않으며 제어문에 괄호를 사용하지 않으며 루아가 지원하는 복합 데이터 형식은 '테이블'하나 뿐임
  테이블은 다음 코드처럼 배열, 리스트, 집합 등 다양한 방식으로 활용할 수 있음
--주석-- 
-- 배열로 만든다, 배열의 인덱스는 1에서 시작
t = { 1, 2, 3, 4, 5 }
-- 4 출력
print(t[4])

-- 딕셔너리로 만듬
t = { M = "Monday", T = "Tuesday", W = "Wednesday" }
-- Tuesday 출력
print(t[T])

  루아는 객체지향 언어가 아니지만 테이블을 잘 활용하면 OOP를 완벽하게 구현할 수 있음. 이는 게임에 OOP를 적용해야할 일이 생기면 유용하게 사용

언리얼스크립트
  에픽의 언리얼 엔진용으로 설계한 엄격한 객체지향 언어. 다른 스크립트 언어와 달리 얼리얼 스크립트는 컴파일이 필요함
  그러므로 성능이 인터프리터 언어보다 뛰어나지만 실행 중에 스크립트를 다시 로드할 수 없음
  언리얼을 사용하는 게임은 보통 게임 플레이에 관한 모든 코드를 언리얼스크립트로 만듬 무료 UDK만 사용하는 게임이 아닌 언리얼엔진을 통째로 사용하는 게임이라면
  네이티브 바인딩을 통해 언리얼 함수를 C++로 구현할 수 있음
  <img src="/01_unreal_script_native_binding.jpg">
  언리얼스크립트의 문법은 C++, 자바와 매우 비슷함. 모든 클래스는 어떤 식으로든 Object를 상송하며 화면상의 캐린터를 나타내는 클래스는 거의 모두 Actor를 상속
  매우 독특한 특징은 기본적으로 상태를 지원한다는 것. 상태에 따라 함수를 다양하게 정의할 수 있음
  예시) AI행동에 사용할 상태 머신을 아주 쉽게 만들 수 있음
  다음 코드를 보면 클래스의 현재 상태에 따라 다른 Tick함수를 호출. Tick은 언리얼스크립트에서 오브젝트를 업데이트하는 함수
//auto는 이 상태가 기본 상태라는 뜻
auto state Idle {
  fucntion Tick(float DeltaTime) {
    // '대기' 상태에서의 업데이트
    ...
    
    //적을 발견하면 '경계'상태로 넘어감
    GoToState('Alert')
  }
Begin:
  `log("Entering Idle State")
}
state Alert {
  function Tick(float DeltaTime) {
    //'경계'상태에서의 업데이트
    ...
  }
Begin:
  `log("Entering Alert State")
}

비주얼 스크립팅 시스템(visual scripting system)
  요즘은 흐름도에서 보이는 비주얼 스크립트 시스템을 제공하는 게임엔진이 많아짐. 이는 주로 레벨 로직을 만들 때 사용
  비주얼 스크립팅 시스템을 사용하면 플레이어가 문을 여자 마자 적이 등장하게 하는 등의 동작을 코드가 아닌 흐름도를 통해 간단하게 설명할 수 있음
  <img src="/02_visual_scripting_system.jpg">
  
스크립트 언어의 구현 
  스크립트 언어의 구현 방법을 전부 설명하면 책의 범위를 넘어서나 적어도 구현에 꼭 필요한 요소 정도는 살펴볼 필요가 있음
  스크립트 언어를 사용할 때 발생하는 문제의 복잡함을 알려주고 올바른 해법을 찾는데 도움이 될 것임
  전용 스크립트 언어를 구현하는 방법은 기본적으로 범용 컴파일러를 만드는 방법과 매우 비슷함. 컴파일러관련 서적을 참고할 필요가 있음
  컴파일러를 직접 구현할 일이 없더라도 프로그래밍의 수준을 한 단계 높이려면 컴파일러의 기본적인 동작 방식을 잘 알아야함
  컴파일러 이론이 없었다면 아직도 코드를 어셈블리로 작성해야했을수도 있음
토큰화(tokenization)
  언어를 읽어들이려면 텍스트로 이뤄진 코드를 식별자, 키워드, 연산자, 기호와 같은 토큰으로 분해해야함
  좀더 고급진 단어로 어휘분석(texical analysis)
  <img src="/03_tokenization.jpg">
  스캐너, 렉서라고도 하는 어휘 분석기를 직접 작성할 수도 있지만 권장할 만한 작업은 아님. 직접어휘 분석기를 작성하려면 처리해야할 상황이 너무 많으므로 오류가 발생하기 쉬움
  예를 들어 C++어휘 분석기는 다음 키워드 중 단 하나만 실제 new 키워드로 인식할 수 있어야함
  newnew, _new, new_new, _new_, new 등...
  어휘 분석기를 직접 만들지 말고 어휘 분석기를 만들어주는 플렉스같은 툴을 사용하는 쪽이 나음
  플렉스에게 정규표현식이라는 일련의 매칭 규칙을 전달하면 자동으로 규칙에 맞는 토큰을 뽑아내는 어휘 분석기 코드를 만들어줌
정규표현식(regular expression)
  regex라고도 하는 정규표현식은 토큰화 외에도 용도가 다양함. 대부분의 IDE는 검색을 수행할 때 정규표현식을 사용함
  정규표현식을 사용하면 여러 파일에 들어있는 키워드같은 연속적인 문자나 숫자 형태를 쉽게 찾을 수 있음.
  일반적인 정규표현식은 상당히 복잡하지만 스크립트 언어의 구현에 필요한 패턴 매칭 정도는 정규표현식의 극히 일부만 활용해도 충분
  가장 기본적인 정규표현식은 항상 모든 문자가 같은 순서로 이어져야 하는 키워드와 일치하는 형태
  키워드와 일치하는 정규표현식은 다음과 같이 따옴표와 관계없이 연속으로 이어진 문자로 이루어짐
//new 키워드와 일치
new
//역시 new 키워드와 일치
"new"
  정규표현식에서 특별한 의미를 지니는 연산자도 존재하는데 []연산자는 대괄호 안의 문자 중 하나와 일치해야 한다는 의미
  또한 다음과 같이 하이픈과 조합해서 문자의 범위를 지정하기도 함
//aac, abc, acc 에만 해당
a[abc]c

//aac, abc, acc ... , azc에 해당
a[a-z]c

//여러 범위를 조합할 수도 있음
//aac, ... ,azc는 물론 aAc, ..., aZC 와도 일치
a[a-zA-Z]c

  + 연산자는 '하나 이상의 문자'를 뜻하고 * 연산자는 '문자가 0개 이상'임을 의미
  이런 연산자와 [] 연산자를 조합하면 언어에서 쓰이는 거의 모든 토큰의 형식을 정의하는 표현식을 만들 수 있음
//하나 이상의 숫자에 해당, 즉 정수 토큰
[0-9]+

//하나의 문자 또는 언더스코어의 뒤에 문자, 숫자, 언더스코어가 0개 이상 붙는 형태에 해당. 즉 C++의 식별자에 해당
[a-zA-Z_][a-zA-Z0-9_]*
  
  어쨌든 토큰과 토큰에 해당하는 정규표현식의 목록을 만들고 나면 플렉스같은 프로그램에 전달해서 자동으로 어휘 분석기를 생성할 수 있음
  개발자가 작성한 스크립트를 어휘 분석기에 넣어서 토큰으로 분해했다면 다음 단계로 넘어가야함
구문분석(syntax analysis)
  분해한 토큰이 언어의 문법을 제대로 따르고 있는지 확인하는 역할을 수행
  스크립트의 문법을 확인하는 동안 전체 프로그램의구조를 정의하는 트리 형태의 데이터 구조인 추상 구문 트리(AST, Abstract Syntax Tree)
  <img src="/04_AST.jpg">
  그림의 트리를 왼쪽 자식노드, 오른쪽 자식노드, 부모노드의 순서로 후위탐색(post-order traversal)한 결과는 5 6 10 * + 이다.
  중위표기법(infix)으로 5 + 6 * 10 인 수식을 후위표기법(postfix)으로 바꾼 결과와 같음
  후위 표기법은 스택과 찰떡궁합이므로 수식을 후위 표기법으로 표기하면 훨씬 쉽게 계산할 수 있으므로 수식이든 아니든 모든 AST는 구문 분석 후에 후위탐색을 거쳐야함
  AST를 만드는 첫 단계로 언어의 문법을 정의해야 함.
  컴퓨터 언어의 문법을 정의하는 대표적인 방법은 베커스 나우어 표기법(BNF, Backus-Naur Form)을 정의하는 것
  BNF의 형식은 비교적 간단함. 온전한 덧셈, 뺄셈을 수행할 수 있는 계산기의 문법은 다음과 같이 정의할 수 있음
  <정수> ::== [0-9]+
  <수식> ::== <수식>"+"<수식> | <수식>"-"<수식> | <수식>
  ::== 연산자는 '~로 정의한다'라는 뜻, | 연산자는 또는 이라는 뜻, <>는 문법 규칙의 이름을 나타냄
  따라서 앞서 소개한 BNF문법은 수식과  다른 수식을 더하는 수식, 빼는 수식 또는 정수로만 이루어진 수식을 나타냄
  즉 5+6은 타당한 수식임. 5,6은 정수고 각각 정수로만 이뤄진 수식에 해당하므로 두 수식을 더할 수 있기 때문
  토큰화와 마찬가지로 구문 분석을 도와주는 툴도 존재. 바이슨(bison)같은 툴을 사용하면 문법 규칙이 일치할 때마다 원하는 C, C++ 동작을 실행하게 만들 수 있음
  일반적으로 이런 동작을 처리하는 방법은 AST에 적절한 노드를 생성하느 것.
  예를 들어 덧셈과 일치하는 수식을 발견하면 왼쪽, 오른쪽 피연산자를 자식 노드로 지니는 덧셈노드를 생각할 수 있음
  즉, 각 노드의 형식과 일치하는 클래스를 만드는 방법이 최선이라는 뜻. 따라서 덧셈, 뺄셈 문법에는 수식을 추상화한 기본 클래스와 정수노드, 덧셈노드, 뺄셈노드에 해당하는 클래스 등
  총 네 개의 클래스가 필요함. 클래스의 계층은 다음과 같음
  <img src="/05_class.jpg">
코드 실행 또는 코드 생성 
  스크립트 파일에서 AST를 만들고 나면 이제 둘 중 하나의 과정을 거쳐야만 함. 어쨌든 둘 다 후위탐색이 필요함
  전통적인 방식의 컴파일러에서 AST탐색의 목표는 타겟 기기에서 실행할 실제 코드를 만들어내는 것
  C++컴파일러는 AST를 탐색하면서 타겟 플랫폼에서 작동할 수 있는 어셈블리 코드를 만들어냄
  앞서 말했듯이 언리얼스크립트같은 게임 스크립트 언어는 컴파일할 때 코드를 생성하는 과정을 거침. 하지만 인터프리터 언어라면 코드 생성 과정이 필요 없음
  AST탐색은 단순히 탐색으로 끝내고 노드가 나타내는 동작을 실행하는 쪽이 바람직
  덧셈, 뺄셈의 예에서 노드는 다음과 같이 정의할 수 있음
abstract class Expression
  function Execute()
end

class Integer inherits Expression
  //정수 값을 저장
  int value
  
  //생성자
  ...
  
  function Execute()
    //연산 스택에 값을 푸시
    ...
  end
end

/Addition(덧셈)노드
class Addition inherits Expression
  //왼쪽, 오른쪽 피연산자
  Expression lhs, rhs
  
  //생성자
  ...
  
  function Execute()
    //후위탐색이란 왼쪽, 오른쪽, 자신의 순서로 탐색한다는 뜻
    lhs.Execute()
    rhs.Execute()
    
    //연산 스택의 맨 위에 있는 두 값을 더한 뒤에 더한 결과를 스택에 푸시
    ...
  end
end
//Substraction(뺄셈) 노드는 연산이 뺄셈이라는 점을 제외하면 덧셈노드와 똑같음
...

  이 클래스를 사용하면 루트 노드에서 Execute를 호출해 AST의 결과를 계산할 수 있음. 함수가 리턴한 뒤에 스택 안에 홀로 남아있는 값은 연산결과에 해당
  예시)5+6 연산
    AST에서 루트노드가 Addition 클래스고 왼쪽 자식노드는 값이 5인 Integer클래스, 오른쪽 자식노드는 값이 6인 Integer클래스로 이뤄짐
    따라서 루트노드인 Addition 노드에서 Execute를 호출하면 먼저 왼쪽노드 5에서 Execute를 호출해 연산 스택에 5를 푸시
    그런 다음 노드 6에서 연산 스택에 6을 푸시. 마지막으로 루트 노드의 Execute에서 스택의 맨 위 두 값을 더한 뒤에 최종 결과인 11을 다시 스택에 푸시
  물론 실제 스크립트 언어는 기초적인 수학 계산 이상의 다양한 기능을 지원하므로 Execute함수가 훨씬 복잡해질 것. 하지만 아무리 언어의 문법이나 노드 형식이 복잡해도 후위탐색이라는 원칙은 유지
  
데이터 형식 
  그 밖에도 게임을 개발하는 동안 저장해야할 데이터를 표현할 방법을 결정해야함
  간단한 게임이라면 데이터를 하드코딩할 수 있지만 좋은 방법이 아님. 데이터를 별도의 파일에 저장하면 프로그래머가 아니어도 수정할 수 있다는 장점이 있음
  또한 데이터를 훨씬 쉽게 다룰 수 있는 레벨 편집기같은 툴 프로그램을 만드는 방법도 생각해볼 가능성이 열림
  데이터 형식을 결정하려면 먼저 데이터를 바이너리로 저장할지 텍스트로 저장할지 결정해야함
    바이너리 파일에는 사람이 읽을 수 없는 형태의 데이터가 들어있음. 예시)이미지파일 형식
    텍스트 파일은 표준 아스키문자로 이루어져 있어 사람이 읽을 수 있음
  사용할 스크립트 언어를 결정할 때와 마찬가지로 각 형식의 장단점을 따져봐야함
각 형식의 장단점
  바이너리 파일의 장점은 파일의 크기가 작아진다는 것과 더 빨리 로드할 수 있다는 것에 있음
  텍스트 파일은 파싱해서 메모리에 올릴 수 있는 형태로 변환하려면 시간이 걸리지만 바이너리 파일은 대개 변환 없이 바로 메모리에 올릴 수 있음
  게임에서는 효율성이 매우 중요하므로 레벨 구성 정보처럼 용량이 큰 정보를 저장해야할 파일이라면 바이너리로 저장하는 것이 효율적임
  속도 면에서는 장점이 있지만 단점도 있음. 바이너리 파일은 버전 관리 시스템과 함께 사용하기 어려움
  바이너리 파일을 수정했을 때 원ㄹ ㅐ파일과 수정한 파일의 차이점을 알아내기가 쉽지않기때문
  예시) 언리얼의 .pkg파일 같은 바이너리 파일에 레벨 데이터를 저장해 게임을 개발 중인데 레벨 디자이너가 레벨 편집기를 사용해서 레벨의 열 군데를 수정한 뒤에 업데이트 했다고 가정
    갑자기 레벨을 로드할 수 없는 문제가 발생해서 버그를 찾아내야하지만 바이너리파일에서 문제가 있는 부분을 집어낼 방법이 없으므로 수정할 내용을 전부 되돌릴 수 밖에 없음
    하지만 텍스트 파일 형식이라면 파일의 차이점을 매우 쉽게 확인하여 열 군데 중 문제인 한 군데를 찾아서 그 부분만 되돌릴 수 있었을 것
  텍스트 파일 형식은 사용자가 직접 수정할 수 있다는 장점이 있음. 하지만 레벨 데이터를 텍스트로 저장하면 플레이어가 멋대로 레벨데이터를 수정해서 게임을 망칠 수 있음
  같은 데이터를 텍스트와 바이너리로 동시에 표현하는 방법이 있음. 개발 중에는 수정 내용을 쉽게 추적할 수 있어야 편하므로 레벨과 게임오브젝트 데이터를 모두 텍스트로 저장하면서 개발을 진행함
  실제로 배포할 때는 베이크(bake)라는 과정을 통해 텍스트 데이터를 효율적인 바이너리 형식으로 변환함
  이 바이너리 파일은 절대 버전 관리 시스템에 올라가지 않으며 개발자가 다루는 데이터는 텍스트 형식의 데이터 뿐
  즉, 개발 중에는 텍스트 파일의 장점을 살릴 수 있고 배포할 때는 바이너리 파일의 장점을 살릴 수 있음
  이때 테스트에 신경써서 개발팀은 텍스트 형식으로 수정할 내용을 바이너리로 바꿨을 때 문제를 일으키지 않는지 주의해야함
바이너리 형식 
  게임 데이터를 저장할 바이너리 파일의 형식은 개발자의 취향에 따라 다양하게 바뀔 수 있음
  데이터를 저장하는 방법은 매우 다양하며 언어, 프레임워크에 따라서도 달라짐
  C++로 개발 중일때 가장 간단한 데이터 저장 방법은 클래스의 내용을 직접 파일에 기록하는 직렬화(serialization)
  직렬화를 사용할 때, 클래스 내에 동적으로 할당한 데이터가 있다면 깊은 복사를 통해 포인터가 가리키는 내용을 저장한 뒤에 나중에 동적으로 데이터를 복구해야함
  바이너리 파일 형식의 설계 방법은 좀 복잡한 범위임
INI 
  가장 간단한 텍스트 파일 형식은 사용자가 수정할 수 있는 설정 파일에 많이 쓰에는 INI임
  INI파일은 몇 개의 섹션으로 나뉘며 각 세션은 키와 값의 목록으로 이루어짐
  예시) INI파일의 그래픽 설정
[Graphics]
Width=1680
Height=1050
FullScreen=true
Vsync=false
  간단한 데이터라면 INI파일로도 별문제가 없지만 복잡한 데이터는 INI파일로 다루기 힘듬
  특히 섹션의 중첩을 지원하지 않으므로 레벨 구성 데이터 등에 쓰기 좋은 파일 형식이 아님
  INI파일은 간단하면서 널리 쓰이는 형식이므로 쉽게 다룰 수 있도록 도움주는 라이브러리가 많이 존재, 예시) C, C++로 개발 중이라면 다양한 플랫폼을 지원하며 사용법이 간단한 minIni 사용 추천
XML(Extensible Markup Language)
  HTML의 개념을 확장한 파일 형식. XML을 사용하면 HTML태그를 그대로 사용하지 않고 원하는 태그,속성을 따로 만들 수 있음
  따라서 잘 모르는 사람에게는 HTML처럼 보일 수도 있음. <더 위쳐>는 아예 게임에 등장하는 다양한 아이템의 모든 파라미터를 XML로 저장함
  예시)검에 관한 능력치
<ability name="Forgotten Sword of Vrans _Stats">
  <damage_min mult="false" always_random="false" min="50" max="50"/>
  <damage_max mult="false always_random="false" min="55" max="55"/>
  <endurance mult="false always_random="false" min="1" max="1"/>
  <crt_freeze display_perc="true" mult="true" alway_random="false" min="0.2" max="0.2" type="critical"/>
  <instant_kill_chance display_perc="true" mult="false" always_random="false" min="0.02" max="0.02" type="bonus"/>
  <vitality_regen mult="false" always_random="false" min="2" max="2"/>
</abiltiy>
  XML의 가장 큰 문제점은 데이터를 표현하는데 필요한 문자가 너무 많다는 것. 이는 텍스트 파일의 크기가 커지는데 일조함
  하지만 큰 장점은 태그나 속성이 지켜야 할 요건을 나타내는 스키마(schema)를 강제한다는 점
  즉 XML파일이 유효한지 그리고 필요한 파라미터를 모두 선언했는지 쉽게 확인할 수 있음
  XML역시 지원하는 파서가 다양함. C, C++에서 가장 널리 쓰이는 파서는 TinyXML과 TiCPP
  C#에는 XML파일을 전담하는 SystemXml이라는 네임스페이스가 있듯이 XML파싱을 기본적으로 지원하는 언어도 있음
JSON(JavaScript Object Notation)
  INI나 XML보다 늦게 만들어진 파일형식이지만 다른 형식만큼이나 많이 쓰이는 형식
  JSON은 인터넷을 통해 데이터를 전송할 때 주로 쓰이지만 게임에서 간단한 데이터 형식을 다룰 때도 사용할 수 있음
  JSON파싱을 지원하는 써드파티 라이브러리로는 C++용인 libjson, C#과 기타 닷넷 언어용인 JSON.NET 등이 있음
  저장할 데이터의 형식에 따라 JSON파일은 XML파일보다 더 작고 파싱도 더 효율적일 수 있으나 항상 그렇지는 않음
  위의 XML로 저장한 검 데이터를 JSON으로 저장하면 다음과 같이 더 길어짐
"ability": {
  "name": "Forgotten Sword of Vrans _Stats",
  "damage_min": {
    "mult": false, "always_random": false, "min": 50, "max": 50
  },
  "damage_max": {
    "mult": false, "always_random": false, "min": 55, "max": 55
  },
  "endurance": {
    ...
  }
  "crt_freez": {
    ...
  }
  "instant_kill_change": {
    ...
  }
  "vitality_regen": {
    ...
  }
}
  JSON파일과 XML파일 양쪽의 공백과 줄 바꿈을 모두 제거한다 해도 여전히 JSON파일이 XML파일보다 조금 더 큼
  게임에 따라 더 좋은 데이터 형식을 선택해야함
  
사례연구 : <월드 오브 워크래프트>의 UI MOD
  WOW의 UI MOD는 스크립트 언어와 텍스트 형식 데이터 표현 둘을 활용함
  대부분 게임의 UI는 디자이너나 개발자가 만들고 플레이어는 단지 만들어진 UI를 사용할 뿐. 설정메뉴를 제공하는 게임이라도 대부분 UI에 관한 설정은 불가능함
  하지만 MMORPG에서 플레이어가 선호하는 UI설정은 플레이어의 수 만큼이나 다양함
  블리자드는 기존 요소의 위치를 바꿀 수 있을 뿐만 아니라 완전히 새로운 요소를 추가할 수 있는 UI시스템을 원했고 이를 위해 UI시스템에 스크립트언어와 텍스트형식 데이터를 적극적으로 사용함
  UI MOD의 두 가지 중요한 요소는 레이아웃과 동작. 이미지, 컨트롤, 버튼 등의 위치 같은 인터페이스 레이아웃은 XML로 저장
  그리고 UI의 동작은 스크립트 언어인 루아를 사용해서 구현
레이아웃과 이벤트
  인터페이스의 레이아웃은 모두 XML을 바탕으로 함
  UI개발자는 프레임, 버튼, 슬라이더, 체크 박스 같은 기본 위젯을 그대로 사용할 수 있으므로 적절한 요소를 사용해서 인터페이스를 선언하면 기본 창처럼 보이는 메뉴도 만들 수 있음
  더 나아가 기본 위젯을 상속한 뒤에 원하는 속성을 덮어쓸 수도 있음
  즉 기본 버튼을 상속해서 속성 몇개만 수정하면 입맛에 맞는 버튼 XML레이아웃을 만들 수 있다는 의미
  또 애드온의 XML파일에 등록할 이벤트를 지정할 수 있음
  WOW의 애드온에는 위젯에 관한 이벤트, 게임 전체에 관한 이벤트 등 다양한 이벤트를 등록할 수 있음(버튼클릭, 슬라이더 이동 등)
  하지만 WOW이벤트 시스템의 진가는 게임 이벤트의 종류가 매우 다양하다는 점에 있음. 다른 플레이어를 공격하거나, 다른 플레이어에게 공격을 받거나, 채팅하거나, 경매장에서 아이템을 확인하는 등
  다양한 동작 중 하나를 수행할 떄마다 게임 이벤트가 발생하고 이르 모드 UI애드온에 등록할 수 있음
  예시)초당 피해량을 알려주는 UI애드온은 전투피해 이벤트를 추적해서 구현할 수 있음
동작 
  각 인터페이스 애드온의 동작은 루아로 구현. 루아를 사용하면 동작을 금세 프로토타이핑할 수 있고 게임이 실행 중이어도 UI를 다시 로드할 수 있다는 장점이 있음
  루아는 테이블을 바탕으로 한 상속을 지원하므로 부모 클래스의 멤버함수를 재정의할 수 있기 때문
  대부분 애드온 코드의 상당 부분은 이벤트를 처리하고 정보를 보여주는 데 초점을 맞춤. 등록한 이벤트마다 해당 이벤트를 처리하는 루아 코드가 있어야함
문제점 : 오토플레이 
  WOW의 UI시스템은 발표와 동시에 큰 성공을 거뒀으나 개발 중에 오토플레이의 가능성이 우려됨
  이를 방지하려고 키를 눌렀을 때 UI MOD가 하나의 동작밖에 수행하지 못하게 만들었음
  플레이어가 스페이스바를 누를 때 애드온은 기껏 하나의 주문을 시전하는 것이 고작이었음
  하지만 그래도 파훼법이 나오자 블리자드는 UI MOD에서 아예 주문을 시전할 수 없게 막았다
문제점 : UI 충돌
  UI MOD는 플레이어가 인터페이스의 핵심 동작까지도 쉽게 수정할 수 있으므로 수정한 내용이 게임을 플레이하지 못할 정도로 심각한 영향을 줄 가능성이 있음
  특히 새로운 패치가 나올 때 이런 일이 많이 발생했는데, 패치와 함께 UI API가 바뀔 때가 많았기 때문
  이로 인해 기술지원팀은 골머리를 앓아 유효기간이 지난 애드온을 배제하는 설정을 추가했으나 대부분 플레이어는 이 기능을 사용하지 않음
  결국 기본 UI가 호출하는 모든 함수에 '안전한'실행경로를 추가하는 방식으로 문제를 해결함
  안전한 호출을 통해 공격, 채팅같은 모든 기본 기능을 처리했고 애드온은 이제 이런 기본 기능을 재정의할 수 없음
  애드온 함수는 재정의가 아닌 안전한 함수에 덧붙이는 방식으로 실행해야 했음
  즉 애드온 함수는 안전한 함수가 실행을 끝낸 뒤에 따로 실행 기회를 얻는다는 의미
결론
  WOW의 UI 애드온 시스템이 엄청난 성공을 거두자 대부분 MMORPG는 비슷한 UI시스템을 채용하였음
  스크립트 언어와 텍스트 파일 형식을 함께 활용하지 않았다면 이렇게 유연하고 강력한 시스템을 만들어내지 못했을 것
  
연습문제
  1. 게임에서 스크립트 언어를 사용할 때의 장점과 단점을 설명
  2. 스크립트 언어를 사용해서 구현하기에 알맞은 게임의 기능 세 가지
  3. 전용 스크립트 언어의 예를 들고 예로 든 언어와 기존 스크립트 언어를 비교했을 때 장단점을 설명
  4. 비주얼 스크립팅 시스템이란? 그 용도는?
  5. 다음 C++구문을 토큰으로 분해
    int xyz = myFunction();
  6. 다음 정규표현식의 의미를 설명
    [a-z][a-zA-Z]*
  7. 추상 구문 트리란? 추상 구문 트리의 용도는?
  8. 게임 데이터를 텍스트 형식과 바이너리 형식으로 저장할 때의 장단점
  9. 기본적인 설정을 저장할 때 사용할 수 있는 파일 형식과 그 이유
  10. WOW UI MOD의 두 가지 요소
  




